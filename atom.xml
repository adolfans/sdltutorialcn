<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[SDL中文教程]]></title>
  <link href="http://adolfans.github.com/sdltutorialcn/atom.xml" rel="self"/>
  <link href="http://adolfans.github.com/sdltutorialcn/"/>
  <updated>2013-01-27T01:57:04+08:00</updated>
  <id>http://adolfans.github.com/sdltutorialcn/</id>
  <author>
    <name><![CDATA[Adolfans]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[第一节: Hello World!]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/lesson-1-hello-world/"/>
    <updated>2013-01-26T20:22:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/lesson-1-hello-world</id>
    <content type="html"><![CDATA[<p>这一节我们将学习将一张图片绘制到屏幕上的简单方法。具体来讲是绘制下面这张图片。</p>

<!-- more -->


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/hello.bmp">
你可以通过右键另存为下载这张图片。<del>这是一个指向一个我建立的Github版本库里的图片的链接，因为这样做会保存一个SDL能够加载的真正的BMP图片。 </del>这个版本库同时也是我教程中例子的源代码和其他相关资源（assets）的主页。如果你丢了资源或者想要偷看一下我的代码，就从<a href = "https://github.com/Twinklebear/TwinklebearDev-Lessons">这里</a>抓好了。但是，不要复制粘贴！</p>

<p>第一步总是include SDL的头文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "SDL.h"</span></code></pre></td></tr></table></div></figure>


<p>注意，这依赖于你的SDL设置。对Linux用户来说，也许需要这样做：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "SDL/SDL.h"
</span><span class='line'>//or
</span><span class='line'>#include "SDL2/SDL.h"
</span><span class='line'>//depending on your configuration</span></code></pre></td></tr></table></div></figure>


<p>——除非你在编译选项里指定了头文件的绝对路径（对linux用户来说）。</p>

<p>首先我们需要启动SDL以便使用它。注意：如果SDL初始化失败的话，它会返回-1。这样的情况下，我们可以使用SDL_GetError()函数来输出错误消息，然后退出程序。</p>

<p>对Visual Studio用户的特殊说明：如果你在连接器选项中把子系统设置为了windows，你将不会看到输出到控制台的结果。要获得这个结果，你必须把子系统改为“未设置”并且把#undef main放到main函数前面。当改回windows子系统的时候，你要确认一下你把#undef main这行代码去掉了，否则你会得到链接错误。</p>

<div><script src='https://gist.github.com/3139888.js?file=a.cpp'></script>
<noscript><pre><code>int main(int argc, char** argv){
    if (SDL_Init(SDL_INIT_EVERYTHING) == -1){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>然后我们还需要创建一个能让我们绘制图像的窗口，我们可以使用SDL_Window:</p>

<div><script src='https://gist.github.com/3139888.js?file=b.cpp'></script>
<noscript><pre><code>    SDL_Window *win = nullptr;
    win = SDL_CreateWindow(&quot;Hello World!&quot;, 100, 100, 640, 480, SDL_WINDOW_SHOWN);
    if (win == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>SDL_CreateWindow这个函数的作用是为我们创建一个窗口，并且返回一个SDL_Window指针。这个函数的第一个参数是窗口的标题，之后是窗口所打开的位置的x,y坐标，之后的参数是窗口的长度和宽度。最后一个参数是窗口的各种flag，因为我们想要窗口在创建之后马上弹出，所以这里我们填SDL_WINDOW_SHOWN。</p>

<p>我们也提供了一些错误安全保障，把指针初始化为了nullptr，并在创建了窗口之后，检查了这个指针是否仍为空。如果创建窗口失败了，这个指针将仍然是空的，这样我们就需要中止这个程序。把指针初始化为空NULL总是很重要的，或者也可以利用C++ 11新标准把它初始化为nullptr。</p>

<p>现在，仅仅只是打开一个窗口对我们来说意义不大，我们需要把东西画到窗口上。所以现在让我们获取一个SDL_Renderer并且运行吧。</p>

<div><script src='https://gist.github.com/3139888.js?file=c.cpp'></script>
<noscript><pre><code>    SDL_Renderer *ren = nullptr;
    ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (ren == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>我们的renderer（渲染器）是用SDL_CreateRenderer这个函数创建的，这个函数还需要我们指定用来绘制的窗口。我们也可以指定一个可选的显卡驱动，或者直接把参数设为-1，好让SDL自动选择适合我们指定的选项的驱动。这样做可能是最好的选择，因为这会让SDL为你选择你所需要的——也就是你在最后一个参数中用那些标志指定的——合适的驱动。</p>

<p>在这里我们指定了SDL_RENDERER_ACCELERATED，因为我们想使用硬件加速的renderer，换句话说就是想利用显卡的力量。我们还指定了 SDL_RENDERER_PRESENTVSYNC标志，因为我们想要使用SDL_RendererPresent这个函数，这个函数将会以显示器的刷新率来更新画面。</p>

<p>注意，在这里我们使用了和之前创建窗口时一样的错误处理方式。</p>

<p>现在是时候加载一张图片并把它画到屏幕上啦！
 It&#8217;s time to load an image to draw to the screen! You should have downloaded the image from the Github repository and saved it in the same folder, or nearby to where your executable will be built too.</p>

<p> Although SDL 2.0 uses SDL_Textures for hardware accelerated rendering, we&#8217;ll still need to load our image to an SDL_Surface using SDL_LoadBMP, as this lesson isn&#8217;t using the fantastic SDL_image extension library (we&#8217;ll get to it soon).</p>

<div><script src='https://gist.github.com/3139888.js?file=d.cpp'></script>
<noscript><pre><code>    SDL_Surface *bmp = nullptr;
    bmp = SDL_LoadBMP(&quot;../res/Lesson1/hello.bmp&quot;);
    if (bmp == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>Note that you will need to change the filepath passed to SDL_LoadBMP to match the location of the image on your machine, or leave it the same if you&#8217;ve decided to follow my folder structure exactly.</p>

<p> To take advantage of hardware accelerated rendering we must next convert our SDL_Surface to an SDL_Texture that the renderer can draw.</p>

<div><script src='https://gist.github.com/3139888.js?file=e.cpp'></script>
<noscript><pre><code>    SDL_Texture *tex = nullptr;
    tex = SDL_CreateTextureFromSurface(ren, bmp);
    SDL_FreeSurface(bmp);</code></pre></noscript></div>


<p>We also free the SDL_Surface at this point because it is no longer needed.</p>

<p> We can now draw our texture to the renderer. First we clear the screen with SDL_RenderClear, then we can draw the texture with SDL_RenderCopy. Finally we update the screen with SDL_RenderPresent.</p>

<div><script src='https://gist.github.com/3139888.js?file=f.cpp'></script>
<noscript><pre><code>    SDL_RenderClear(ren);
    SDL_RenderCopy(ren, tex, NULL, NULL);
    SDL_RenderPresent(ren);</code></pre></noscript></div>


<p>We also pass two NULL values to RenderCopy, the first one is a pointer to the source rectangle, ie. a clip to take of the image sheet while the second is a pointer to the destination rectangle. By passing NULL to both parameters we tell SDL to take the whole image (first NULL) and draw it at 0, 0 and stretch it to fill the entire screen (second NULL), more on this later.</p>

<p> We also tell our program to wait for 2000milliseconds with SDL_Delay so that we can see the screen. Without the delay the window would pop up and then close as the program finishes very quickly.</p>

<div><script src='https://gist.github.com/3139888.js?file=g.cpp'></script>
<noscript><pre><code>    SDL_Delay(2000);</code></pre></noscript></div>


<p> Before we exit our program it is necessary to free the memory used by our window, renderer and texture. This is done using the various SDL_Destroy functions</p>

<div><script src='https://gist.github.com/3139888.js?file=h.cpp'></script>
<noscript><pre><code>    SDL_DestroyTexture(tex);
    SDL_DestroyRenderer(ren);
    SDL_DestroyWindow(win);</code></pre></noscript></div>


<p> Finish the program by quitting SDL, and returning 0.</p>

<p> <div><script src='https://gist.github.com/3139888.js?file=i.cpp'></script>
<noscript><pre><code>    SDL_Quit();</p>

<pre><code>return 0;
</code></pre>

<p>}</code></pre></noscript></div></p>

<p>This Gist brought to you by GitHub.
 Compile the program and check it out! Don&#8217;t forget to put SDL.dll in the same directory as your executable or you&#8217;ll get an error pop-up. If you&#8217;re using Linux you should already have the shared libraries installed in your path so you shouldn&#8217;t have any issues</p>

<p>Congratulations on your first SDL 2.0 program!</p>

<p> Troubleshooting
 If your program fails to compile make sure you&#8217;ve properly configured your libraries and linked to the correct path in your include statement.</p>

<p> If your program complains about SDL.dll missing, make sure it is located in the same folder as the executable.</p>

<p> If your program runs but exits with out displaying anything make sure your image path is set correctly. If that doesn&#8217;t help try writing some cout or file output into the program, although depending on your platform and configuration settings cout may not appear.</p>

<p> End of Lesson 1
 That does it for Lesson 1, I&#8217;ll see you again soon in Lesson 2: Don&#8217;t Put Everything in Main</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译SDL2.0教程】在Visual Studio中配置SDL]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/setting-up-sdl-in-visual-studio/"/>
    <updated>2013-01-26T13:34:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/setting-up-sdl-in-visual-studio</id>
    <content type="html"><![CDATA[<p>既然我们已经把库配置好了，我们就需要在我们的项目中链接SDL库。打开Visual Studio，创建一个新的空白C++工程。<br></p>

<!-- more -->


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setruntimelib.png" title="新建工程" alt="新建工程" /><br>
要让工程识别SDL的头文件和库文件，我们需要编辑几项简单的与包含路径和链接设置有关的选项。
右键单击项目名，打开属性菜单。在C/C++列表下，选择“常规”，然后单击最上面的“附加包含目录”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/settingincludedir.png" title="设置包含目录" alt="设置包含目录" /><br>
选择&#8221;编辑&#8221;。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/additionalincludedir.png" title="附加包含目录" alt="附加包含目录" /><br>
单击“新行”图标增加一行，然后单击文本框右面的浏览按钮（三个点的那个），找到你的SDL文件夹，在其中选择“include”文件夹。点“选择文件夹”，确定并应用以保存你的设置。
下一步我们需要更改运行库。在C/C++列表下，选择“代码生成”，然后找到“运行库”项，把它改为“多线程 DLL (/MD)”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setruntimelib.png" title="运行库" alt="运行库" /><br>
要把库链接上，选择C/c++下面的“连接器（linker）”,选择“常规”，然后点击窗口中间的“附加库目录”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/settinglinkerdir.png" title="链接目录" alt="链接目录" /><br>
和之前一样，点击文本框右侧的朝下的三角箭头按钮，选择编辑。
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/additionallibdir.png" title="附加库目录" alt="附加库目录" /><br>
再一次选择新建，单击浏览按钮。找到你的SDL文件夹，打开lib文件夹，你会看到两个文件夹，32位的x86和64位的x64。你可以任选其一，但是你必须明白VC++默认是编译的32位
程序，你可能需要更改其他设置。在这个教程中，我选择的是x86。点击选择，确认，应用来保存你的设置。<br>
下一步我们必须指定我们将要链接的库文件。于是在连接器菜单里，选择“输入”菜单，点击“附加依赖项”文本框，像之前一样点击右面的三角箭头并选择“编辑”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/settinglibinput.png" title="附加依赖项" alt="附加依赖项" /><br>
要让VC++知道我们想要使用的库，填入</p>

<pre><code>SDL.lib; SDLmain.lib;
</code></pre>


<br>


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setadditiondep.png" title="附加依赖项" alt="附加依赖项" /><br>
点击确认，应用来保存设置。
随后一步是将子系统目标改为windows。选择连接器下的“系统”菜单，将“子系统”条目改为Windows。</p>

<br>


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setsubsystem.png" title="setsubsystem" alt="setsubsystem" /><br>
点击应用，以保存设置，确认关闭窗口。</p>

<br>


<p>现在我们来测试一下我们的配置是否正确。给工程添加一个C++源文件并输入：</p>

<script src="https://gist.github.com/3139836.js"></script>


<p>这段简单的代码将初始化SDL，然后退出。你不会看到任何事发生。尝试编译这个项目，如果有错误提示的话，确认你没有跳过之前任何一步，并确认你是否选择了正确的文件夹。在运行这段代码之前，你应该把SDL路径下，bin文件夹内的动态链接库SDL.dll放到项目可执行文件的文件夹里。否则的话，程序将会运行失败并弹出找不到SDL的错误。<br>
作为最后一件为以后每次创建SDL项目省下麻烦的额外工作，你可以把这个项目导出为一个模板。选择文件菜单然后点击导出模板，然后把它导出为项目模板。你可以给它取个名字也可以为它增加任意你喜欢的描述。现在当我们创建一个新的SDL项目的时候，你只需要选择这个模板，只要你的SDL文件夹没有移动，那么所有的东西都被设置好了。
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/exporttemplate.png" title="exporttemplate" alt="exporttemplate" /><br></p>

<br>


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/sdltemplate.png" title="sdltemplate" alt="sdltemplate" /><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译SDL2.0教程】第0节：配置SDL]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/lesson-0-setting-up-sdl/"/>
    <updated>2013-01-25T23:28:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/lesson-0-setting-up-sdl</id>
    <content type="html"><![CDATA[<p>  <h3>
SDL2.0说明</h3>
截至到2012年6月17日我写这篇帖子为止，SDL2.0还没有发布官方正式版本，因此你需要用你所用的编辑器自行编译。</p>

<!-- more -->


<p>  <br>
  <br>
  你可以在<a href="http://www.libsdl.org/hg.php">这里</a>下载它。
  <br>
  <br>
你可以从Mecurial版本库里clone一份最新的源码，但下载一份快照也是个不错的选择。在实际写代码的时候，需要clone他们的Mercurial版本库来下载我们要用到的扩展库。
  <br>
  <br>
在下载完之后，就很容易设置了。注意扩展库SDL_image, SDL_ttf还有SDL_mixer是依赖于SDL的，你需要指定包含路径和链接设置来编译，其中SDL要先编译。</p>

<p>  <br>
  <br>
注意源码文件夹里已经包含了怎样在各个平台上编译构建的文档说明，它们应该能够帮你构建并确认一切是否正常，你也可以继续阅读。
  <br>
  <br>
SDL2.0发布官方正式版时，我会更新链接，这样你们就可以直接下载编译好的库，这就更容易了。
  <br>
  <br>
  <h3>
C++11说明</h3>
在这个教程中，我们会使用一些C++11新标准中的特性，因此你可以选择使用支持这些新标准的编译器，也可以把这些代码翻译成你所使用的编译器所支持的代码，这不会太痛苦。Visual Studio 2012支持C++11,如果你用的是GCC，你可以通过增加-std=c++0x的编译选项来启用C++11特性。</p>

<p>  <br>
  <br>
  <h3></p>

<p>Visual Studio</h3>
源码文件夹里应该包含了一个叫VisualC的文件夹，如果你打开项目解决方案时被提示更新项目，照做就是。在构建之前，确定你选择生成的是Release版本。这样解决方案应该会顺利生成。主目录里有一个VisualC.html文件，里面包含的信息如果你在编译出问题的时候应该很有用。
  <br>
  <br></p>

<p>在生成扩展库的时候，确认你生成的是Release版本。注意在你编译之前，你需要指定SDL2.0的包含路径(include directory，头文件路径)和库路径(library directory)。
  <br>
  <br>
  <b>SDL_mixer的说明：</b>
很不幸我没能在Visual Studio中生成SDL_mixer，尽管它能在Linux里正常使用。所以我觉得Visual Studio的工程文件有点问题。
  <br>
  <br>
当你全部生成完所有的库之后，你要把头文件，lib库文件还有dll放到你不会忘得地方，因为我们会在我们的项目中使用到这些文件。我的路径是C:\
  <br>
  <br>
  <a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/setting-up-sdl-in-visual-studio/">这里</a>有如何创建你第一个SDL项目的教程。
  <br>
  <br>
  <h3>
Linux </h3>
Linux用户只需要使用标准的configure,make,make install.注意要记下你的头文件和库文件的安装路径，因为你在之后编译项目的时候需要指定这些路径。另外你也可以把库和头文件移到标准路径下。你可以把运行库放到或者链接到/lib/路径下，或者放到其他存放运行库的备用路径下面。
  <br>
  <br></p>

<p>关于Linux里编译命令的教程在
  <a href="http://twinklebeardev.blogspot.com/2012/07/setting-up-sdl-on-linux-command-line.html">这里</a>。
  .
  <br>
  <br>
  <h3></p>

<p>Mac</h3></p>

<p>源代码文件夹还包含了一个XCode的工程，但我没有Mac电脑所以很不幸我无法提供更多的指导。在源码中包含的文档里查找关于构建这些库以及如何包含头文件和库文件的信息吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译SDL2.0教程】目录]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/sdl-2-dot-0-tutorial-index/"/>
    <updated>2013-01-25T23:12:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/sdl-2-dot-0-tutorial-index</id>
    <content type="html"><![CDATA[<p>原文地址:<a href = "http://twinklebeardev.blogspot.com/p/sdl-20-tutorial-index.html">SDL 2.0 Tutorial Index</a></p>

<h3>Welcome!</h3>


<p>下面的教程目的是为你提供一个关于SDL2.0以及c++中游戏设计主题和概念的介绍。在本教程中，我们假定你对C++有一定程度上的知识，至少了解数组，vector，控制结构，函数还有指针。<br /><br />
如果你觉得理解教程中的代码有困难，你可以在教程后面随意留言，或者在<a href="http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">StackOverflow</a>上的这个列表里抓一本书来读。<br /><br />
如果你想要查看或者下载全部的程序代码，你可以在<a href="https://github.com/Twinklebear/TwinklebearDev-Lessons">Github</a>上下载到。但是不要复制！<br /><br />
SDL2.0的文档现在可以在<a href="http://wiki.libsdl.org/moin.cgi/FrontPage">online wiki</a>上查看到。<br /><br /></p>

<h3>教程目录：</h3>


<p><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-0-setting-up-sdl.html"><b>Lesson 0: Setting up SDL</b></a>&nbsp;<a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/lesson-0-setting-up-sdl/">第0节：配置SDL</a> <br />
<a href="http://twinklebeardev.blogspot.com/2012/07/lesson-1-hello-world.html"><b>Lesson 1: Hello World!</b></a><br />
<a href="http://twinklebeardev.blogspot.com/2012/07/lesson-2-dont-put-everything-in-main.html"><b>Lesson 2: Don&#8217;t Put Everything in Main</b></a><br />
<b><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-3-sdl-extension-libraries.html">Lesson 3: SDL Extension Libraries&nbsp;</a></b><br />
<b><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-4-event-driven-programming.html">Lesson 4: Event Driven Programming</a></b><br />
<a href="http://twinklebeardev.blogspot.com/2012/08/lesson-5-clipping-sprite-sheets.html"><b>Lesson 5: Clipping Sprite Sheets&nbsp;&nbsp;</b></a><br />
<a href="http://twinklebeardev.blogspot.com/2012/08/lesson-6-true-type-fonts-with-sdlttf.html"><b>Lesson 6: True Type Fonts with SDL_ttf</b></a><br />
<b><a href="http://twinklebeardev.blogspot.com/2012/09/lesson-7-taking-advantage-of-classes.html">Lesson 7: Taking Advantage of Classes</a></b><br />
<a href="http://twinklebeardev.blogspot.com/2012/10/lesson-8-timers.html"><b>Lesson 8: Timers </b></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello world]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/hello-world/"/>
    <updated>2013-01-25T21:16:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/hello-world</id>
    <content type="html"><![CDATA[<p>这是一个测试。</p>

<pre><code>这是一个代码区块。
</code></pre>

]]></content>
  </entry>
  
</feed>
