<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[SDL中文教程]]></title>
  <link href="http://adolfans.github.com/sdltutorialcn/atom.xml" rel="self"/>
  <link href="http://adolfans.github.com/sdltutorialcn/"/>
  <updated>2013-02-14T02:41:19+08:00</updated>
  <id>http://adolfans.github.com/sdltutorialcn/</id>
  <author>
    <name><![CDATA[Adolfans]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[第八节：定时器]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-8-timers/"/>
    <updated>2013-01-28T12:17:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-8-timers</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第七节：充分利用类]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-7-taking-advantage-of-classes/"/>
    <updated>2013-01-28T12:17:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-7-taking-advantage-of-classes</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第六节: 使用SDL_ttf绘制True Type字体]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-6-true-type-fonts-with-sdl-ttf/"/>
    <updated>2013-01-28T12:16:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-6-true-type-fonts-with-sdl-ttf</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第五节：裁剪精灵表]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-5-clipping-sprite-sheets/"/>
    <updated>2013-01-28T12:16:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-5-clipping-sprite-sheets</id>
    <content type="html"><![CDATA[<p>原文链接: <a href="http://twinklebeardev.blogspot.com/2012/08/lesson-5-clipping-sprite-sheets.html">http://twinklebeardev.blogspot.com/2012/08/lesson-5-clipping-sprite-sheets.html</a></p>

<p>It&#8217;s very common in sprite based games to use a large image file containing many smaller images, such as tiles for a tileset, as opposed to having a separate image file for each tile. This type of image is known as a sprite sheet, and is very useful because we don&#8217;t need to have a separate image file for each image in the game but instead can just draw the subset of the sheet that we want.</p>

<p>在基于精灵的游戏中，使用一幅包含了许多小图的大图——比如说使用包含tile的tile集，而不是一个tile就是一张独立的图片——这种方式是非常常见的。这种图像的类型被称作精灵表（sprite sheet，我不能确定我这么翻译是否恰当——译注）。这种方式很有用，因为这样做我们的游戏就用不着每幅图像都用一个独立的文件来存储，而直接绘制表中我们需要的一部分就好了。</p>

<!-- more -->


<p><em>译注：我不确定看这篇文章的初学者们——仅针对初学者们——是否理解诸如精灵、tile之类词语的含义。在2D游戏中，精灵大概就是2D游戏中能够移动来移动去的图块；至于tile，它大概算是精灵的子集，它的中文名称本来是瓦片，一般我们可以看到很多2D游戏的场景是由很多相同的图块拼出来的，那一块一块儿的玩意儿就是tile.欲纠结此问题请看维基百科Sprite_(computer_graphics)词条……= =</em></p>

<p>In this lesson we will learn how to use a simple sprite sheet in our program and how we can specify the desired subset, known as a clip, to draw. The sprite sheet for this lesson is a simple one containing four circles:</p>

<p>本节中我们将学习怎样使用一个简单的精灵表以及怎样指定精灵表中我们需要的子集，也就是绘制时的裁剪。本节的精灵表是一幅有四个圆形的简单图像。</p>

<p><img src="https://raw.github.com/Twinklebear/TwinklebearDev-Lessons/master/res/Lesson5/image.png"></p>

<p>In a sprite sheet images are divided up into sections of some sort of basic shape that we can clip. In this sheet each circle is within a 100x100 rectangle that we can pick to draw, instead of the entire image.</p>

<p>在一个精灵表中，像被分割成了一些我们能够裁剪的基础图形。在这个表中呢，每个圆形都处于一个100x100的矩形中，这样我们就可以单独绘制而不是绘制整个图像。</p>

<p>The code from this lesson will be building upon the code from Lesson 4, if you haven&#8217;t done Lesson 4 you should head back and do it. If you already know the material covered in Lesson 4 grab the code and let&#8217;s get started.</p>

<p>本节的代码都是基于第四节中的代码的。如果你没有学完第四节，你需要回头去看。如果你已经知道了第四节所涵盖的内容，从github上拉取代码后，我们立刻开始。</p>

<p>Within our ApplySurface function from Lesson 4 you&#8217;ll notice that there&#8217;s one last NULL value being passed to SDL_RenderCopy.</p>

<p>通过上一节提到的ApplySurface函数，你可以发现最后传给SDL_RenderCopy一个NULL。</p>

<div><script src='https://gist.github.com/3185765.js?file=1.cpp'></script>
<noscript><pre><code>    SDL_RenderCopy(rend, tex, NULL, &amp;pos);</code></pre></noscript></div>


<p>This parameter is the source rect, more commonly known as the clip, and specifies a sub-rectangle of the image to draw, ie. the clip&#8217;s position, width and height. In order to pass a clip for the image we&#8217;ll want to add a clip parameter to ApplySurface.</p>

<p>而这个参数就是源矩形（rect），被称为clip（裁剪），它指定了需要绘制的图像中的一个子矩形——或者说，它指定了裁剪的位置，宽度，还有高度。为了给源图像传递一个clip，我们需要给ApplySurface函数增加一个clip参数。</p>

<p>But what if we had an image where we did want to draw the whole thing? Instead of forcing ourselves to pass a clip of the whole image, we can instead specify a default parameter and detect when we get it. We&#8217;ll take the clip parameter as an SDL_Rect pointer with a default value of NULL, that way if no clip is passed we can still pass the parameter to RenderCopy and the call will be the same as it was previously when we passed NULL to draw the whole image.</p>

<p>但如果我们有一幅图像，我们想要把它全部绘制出来呢？用不着强迫我们自己传一个整张图片的clip过去，我们只需要指定一个默认的参数并且检测什么时候获得了这个参数就够了。我们要把clip参数当作SDL_Rect类型的指针，并把它的默认值设为NULL。通过这种方式，如果没有clip传入，我们仍可以把该参数传入RenderCopy。结果会是和当我们直接传NULL时一样，绘制整张图。</p>

<p>We&#8217;ll also want to add one more thing to our function: If we pass a clip parameter we clearly would want to use the clip&#8217;s width and height as our destination values instead of the whole texture&#8217;s width and height. If we used the texture&#8217;s width and height our clip would be stretched to match the size of the original texture.</p>

<p>我们还想给我们的函数添加另外一样东西：</p>

<div><script src='https://gist.github.com/3185765.js?file=2.cpp'></script>
<noscript><pre><code>void ApplySurface(int x, int y, SDL_Texture *tex, SDL_Renderer *rend, SDL_Rect *clip = NULL){
    SDL_Rect pos;
    pos.x = x;
    pos.y = y;
    //Detect if we should use clip width settings or texture width
    if (clip != NULL){
        pos.w = clip-&gt;w;
    pos.h = clip-&gt;h;
    }
    else {
        SDL_QueryTexture(tex, NULL, NULL, &amp;pos.w, &amp;pos.h);
    }
    SDL_RenderCopy(rend, tex, clip, &amp;pos);
}</code></pre></noscript></div>


<p> We&#8217;ll load our image the same as before with or LoadImage function.</p>

<p> We now need to set up our clip rects, which we&#8217;ll store inside an array. Instead of typing all of our clips out by hand which is very tedious for images with lots of clips, we can take advantage of the pattern in which our image file is constructed to automate the creation of the clip rects with a for loop. If you did the extra challenge from Lesson 2 this method should look quite familiar.</p>

<p> First we specify the width and height each clip should be, in this case 100x100 and we create an array to store four SDL_Rects to hold our clips. Next we use our knowledge of the arrangement of our clips to create a for loop with a column counter to appropriately set the x,y coordinate for each clip.</p>

<div><script src='https://gist.github.com/3185765.js?file=3.cpp'></script>
<noscript><pre><code>    //iW and iH are the desired clip width and height
    int iW = 100, iH = 100;
    SDL_Rect clips[4];
    //We use a for loop this time to setup our clips
    int column = 0;
    for (int i = 0; i &lt; 4; ++i){
        if (i != 0 &amp;&amp; i % 2 == 0)
            ++column;

        clips[i].x = column * iW;
        clips[i].y = i % 2 * iH;
        clips[i].w = iW;
        clips[i].h = iH;
    }
</code></pre></noscript></div>


<p> If you didn&#8217;t do the Lesson 2 challenge or are feeling a bit lost, let me explain how this works. We want to create four clips, so we set our loop to run four times, from zero to three to match the array indices. We also need to track which column we&#8217;re going down so that we can correctly set the x coordinate for our clip, we&#8217;ll begin with column zero and will increment the column value when we move over, which would be at the third clip, ie. i % 2 == 0 since we start counting from zero. We also want to make sure we don&#8217;t increment column when we first start out, because 0 % 2 is also 0, so we put a condition to ignore that case.</p>

<p> Now we&#8217;ll want to calculate the x and y coordinates for our clip in the image. We want to increment the x coordinate by the image width each time we move over a column, and increase the y each time we move down one in the column. The x coordinate setting should be clear, we can just use tile width * column. The y coordinate setting uses our current loop iteration mod the number of clips per column to determine which row we&#8217;re on. We then multiple this row number by the tile height to get the location in pixels. The width and height are uniform for all clips so we can just set them, without any extra calculations.</p>

<p> Thus when we run this loop we will create four clips and each clip will take the appropriate coordinate for the sub-rectangle. Still not sure how it works? Try running the for loop in your head and calculating the column, x and y values for each iteration and see where they line up on the sprite sheet.</p>

<p> The last step is to set a value which can track which clip we want to draw, in this case an integer corresponding to the clip&#8217;s index in the array. Let&#8217;s begin by drawing clip 0.</p>

<div><script src='https://gist.github.com/3185765.js?file=4.cpp'></script>
<noscript><pre><code>    //Specify a default clip to start with
    int useClip = 0;</code></pre></noscript></div>


<p> Before beginning our main loop we&#8217;ll also need to set an x and y position to draw the image at. I chose to calculate the center position for the image using the same method as in previous lessons. We&#8217;ll also want to create a bool quit variable and an SDL_Event.</p>

<p> In order to make sure our clips were set correctly and display correctly we&#8217;ll want to be able to draw each one individually, to do this we can set up some event polling to change the value of useClip so that we can draw each clip.</p>

<div><script src='https://gist.github.com/3185765.js?file=5.cpp'></script>
<noscript><pre><code>    //If user presses any key
    if (e.type == SDL_KEYDOWN){
        switch (e.key.keysym.sym){
        case SDLK_1:
            useClip = 0;
        break;
        case SDLK_2:
            useClip = 1;
        break;
        case SDLK_3:
            useClip = 2;
        break;
            case SDLK_4:
            useClip = 3;
        break;
            //For quitting, escape key
        case SDLK_ESCAPE:
            quit = true;
        break;
            default:
            break;
    }
    }</code></pre></noscript></div>


<p> Here we check if the input type is a key down event, and then use a switch statement on the key symbol to pick the appropriate response.</p>

<p> Finally in our render section we clear the screen, pass the clip&#8217;s value to our ApplySurface function in the rendering section of our loop:
 <div><script src='https://gist.github.com/3185765.js?file=6.cpp'></script>
<noscript><pre><code>    ApplySurface(x, y, image, renderer, &amp;clips[useClip]);</code></pre></noscript></div></p>

<p>And finally, present the renderer to display the changes.</p>

<p> When you run the program you should be able to push the number keys 1-4 and see the different colored circles appear individually on screen!</p>

<p> End of Lesson 5
 Thanks for joining me! I&#8217;ll see you again soon in Lesson 6: True Type Fonts with SDL_ttf</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第四节：事件驱动的编程]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-4-event-driven-programming/"/>
    <updated>2013-01-28T12:15:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-4-event-driven-programming</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://twinklebeardev.blogspot.com/2012/07/lesson-4-event-driven-programming.html">http://twinklebeardev.blogspot.com/2012/07/lesson-4-event-driven-programming.html</a></p>

<p>Now that we&#8217;ve learned how to draw images to the screen it&#8217;s time to learn how to read user input. Our game won&#8217;t be very good if there&#8217;s no way to play it! In this lesson we will cover simple event handling using SDL and begin designing a primitive &#8216;main loop&#8217;.
既然我们已经学习了怎样往屏幕上绘制图像，现在该学习怎样读取用户的输入了。如果都不能玩的话，我们的游戏就不好了！本节我们会学习SDL的简单事件处理并开始设计一个基本的主循环(&#8220;main loop&#8221;).</p>

<!-- more -->


<p> Before we begin it&#8217;s important to mention that the majority of the code being used for this lesson is the code that we&#8217;ve built up from previous lessons, and as such the repeated code will not be shown as it is assumed you have it already and  are using what you&#8217;re learning here to add on to the previous lesson&#8217;s code. If you don&#8217;t have the code, head back to the earlier lessons, or if you already understand the material grab the code from Lesson 3 off Github and let&#8217;s get started modifying it.
在我们开始之前，要先提到一个重要的问题，本节所使用的大部分代码是上一节中写的。我们假定你已经有了这些代码，所以这些代码这里将不会重复写了，将直接在上一节代码的基础上添加代码。如果你没有这些代码，你可以回头去看前面的几节，又或者如果已经你理解了从github上获取到的第三节的代码，那么就让我们开始改代码吧。
 We&#8217;ll create the renderer and window the same as before, and our LoadImage and ApplySurface functions remain unchanged. The first change to our program is the loading of a different image, note that you will need to change the filepath to match the location of the image relative to the executable on your system, or the program will fail to run.
像以前一样创建renderer和window，loadImage和ApplySurface函数保持原来的样子不变。第一个更改是把加载的图片改成另一张，注意你需要更改文件路径以便与可执行文件的路径匹配，否则的话程序会运行失败。</p>

<div><script src='https://gist.github.com/3161759.js?file=1.cpp'></script>
<noscript><pre><code>//In main...
    SDL_Texture *image = nullptr;
    try {
        image = LoadImage(&quot;../res/Lesson4/image.png&quot;);
    }
    catch (const std::runtime_error &amp;e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        return 4;
    }
    int iW, iH;
    SDL_QueryTexture(image, NULL, NULL, &amp;iW, &amp;iH);
    int x = SCREEN_WIDTH / 2 - iW / 2;
    int y = SCREEN_HEIGHT / 2 - iH / 2;</code></pre></noscript></div>


<p>We also use the same equation as before for centering our image in the window. For this lesson our image will be:
现在，在我们专注于编写主循环和事件处理代码之前，我们需要弄明白SDL event系统是怎样工作的。
<img src="https://raw.github.com/Twinklebear/TwinklebearDev-Lessons/master/res/Lesson4/image.png"></p>

<p> Now before we dive into writing our main loop and event handling code, we&#8217;ll want to get an understanding of how the SDL event system works.
一个事件就是指用户做出的与程序交互的行为，比如：按下键，移动鼠标，鼠标点击，手柄移动，窗口改变大小、最小化或者关闭，等等。SDL提供了一个叫做SDL_Event的结构体来存储这些事件。现在我们创建一个SDL_Event。无论什么时候发生事件，它都会被按时间顺序被存放在一个栈里。如果我们想要读取一个事件，我们可以使用SDL_PollEvent取出一个最老的事件。这可能让人困惑，但是幸运的是，下面这张示意图会使这个问题清晰一点。
An event is any interaction with the program done by the user: keypresses, mouse motion, mouse presses, joystick movement, window resizing, minimizing or closing, etc. SDL provides a structure for storing these events called SDL_Event. Let&#8217;s create one now.
Whenever an event occurs it&#8217;s added to a stack in chronological order. If we want to read an event from this stack we can pull the oldest event using SDL_PollEvent. This may be a bit confusing, hopefully this handy graphic will help make it a bit clearer.
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/lesson4/evntstack.png">
So in this case the user resized the window, then clicked the mouse, then pushed a key. When we call SDL_PollEvent on this queue it will get the event that happened first, or the oldest event, and put it into our SDL_Event structure so that we can look at the event data in our program.
在此情况下，用户更改了窗口大小，然后点了鼠标，然后按了一个键。 当我们调用SDL_PollEvent，它会获取到第一个发生的事件，或者说是最老的那个时间，然后把它放在我们的SDL_Event结构体中，以便于让我们看到这个事件的数据。</p>

<p>So if each frame of our game we want to process all events in the queue we&#8217;ll want to loop through until there&#8217;s nothing left to read, then continue on and do our other stuff like logic and rendering. This is starting to sound like something we could call our main loop!
如果我们希望处理队列中每一帧的消息的话，我们需要循环直到队列中没有任何消息剩余，然后继续做其他的诸如逻辑、绘制之类的工作。这听起来像在主循环中调用的东西。
In each iteration of the loop we&#8217;ll want to process our event queue, do some program logic and draw the frame and then do it all over again until the user quits.
在循环中的每一次遍历中，我们都希望处理事件队列，处理一些程序逻辑然后将这一帧绘制出来，然后重复这些工作直到用户退出程序。</p>

<div><script src='https://gist.github.com/3161759.js?file=2.cpp'></script>
<noscript><pre><code>    SDL_Event e;</code></pre></noscript></div>


<p>Next we&#8217;ll want to do our event polling. Our goal was to run over all the events in the queue each frame, so let&#8217;s use another while loop, as PollEvent will return 1, &#8216;true&#8217;, if there are any pending events, so our loop will run until there are no more events in the queue.
 First we get an event from the queue with SDL_PollEvent, which we pass an address too as its signature is SDL_PollEvent(SDL_Event<em>) and then we do whatever we want to with the input. In this case we&#8217;re just going to quit the program if the user pushes any key, clicks the mouse or closes the window, so if just about anything happens we set quit to true. Note that clicking the X on the window is read as SDL_QUIT.
下一步，我们需要做的是事件轮询。我们的目标是读取每帧中的所有事件，所以我们使用另一个while循环。因为当没有未处理的消息的时候，PollEvent会返回1，也就是true，所以我们的循环会持续直到队列中再没有任何事件。首先，我们使用SDL_PollEvent得到一个事件，因为函数声明是 SDL_PollEvent(SDL_Event</em>) 所以我们需要传入一个地址，然后我们对获得的输入做所有我们需要的处理。在本例中，我们想要当用户按下任意按键，点击鼠标或者关闭窗口的时候直接退出程序，所以如果发生了什么事件的话，我们就把quit设为true。注意，单击窗口右上的红叉会被识别为SDL_QUIT.
SDL&#8217;s event structure is able to read many different types of events and provides all the valid information tied to each event that may be needed in deciding what to do with the input. For more information on the various event types and the data that comes with them, check out the SDL_Event documentation.
SDL的event结构可以获取很多种类型的事件，并且能够提供与每个事件有关的所有有用的信息供你决定怎样处理用户输入。如果你想知道关于多种事件类型和event类型的数据的信息，就去看SDL_Event的相关文档吧。
The next step in our loop would be to do various calculations that our program needs to do, such as determining movement, collision outcomes and etc. However since our program is very primitive we don&#8217;t need to do any logic at the moment, so we&#8217;ll continue on to rendering.
主循环的下一步是把我们程序该计算的计算出来，比如判断移动、碰撞输出等等……尽管如此，因为我们的程序非常原始，现在我们不需要做太多的逻辑操作，所以我们继续绘制图像。
 The code is identical to before, but we must be sure each time to clear the screen before drawing our new scene or we could have images left over from previous frames start showing up.
代码和之前的是相同的，但是我们必须确定我们每次绘制新的场景之前都清空了屏幕。不这么做的话，我们会让上一帧绘制的图像在下一帧里依旧显示着。
 You&#8217;ll want to wrap up the program by destroying the texture, renderer and window and quit SDL.
最后你需要释放掉texture、renderer还有window所占用的内存，退出SDL。</p>

<p> When you run the program you should be able to quit by clicking the X on the window, clicking in the window or pressing a key while the window is selected. You may also notice something a bit interesting when running the program if you check its CPU usage. If you&#8217;ve seen tutorials where the main loop is discussed or have written SDL1.2 code you&#8217;d expect that our program for this lesson would max out one of your CPU cores because there&#8217;s no framerate limiting being done. This is no longer the case with our program as we have created our renderer with the SDL_PRESENTVSYNC flag which tells the renderer to delay and match the framerate of our monitor, letting SDL take care of the framerate limiting for us, and letting us skip writing a line or two of code.
当你运行这个程序的时候，你可以通过在窗口激活的状态下点击窗口的红叉、在窗口中点击或者按下任何一个按键来退出程序。如果你查看了CPU占用的话，你也许会注意到一个有趣的东西。如果你看过讨论主循环的教程，或者写过SDL1.2的代码，你会发现我们本节的程序会把你CPU的一个核心占用到最大程度，这是因为这个程序并没有对帧率做任何限制。但这已经不是问题了，因为我们创建的renderer使用了SDL_PRESENTVSYNC这个flag，它会告诉renderer延迟绘制以匹配显示器的刷新率，让SDL自动为我们控制帧率，为我们省下了一到两行的代码。</p>

<p> Lesson 4 Extra Challenge!
 Try getting the image to move on the screen.
 Hint
第四节的额外挑战！
试着让图像移动起来吧~
提示</p>

<p>第四节的结束
感谢加入！我们第五节：裁剪精灵表见~
 End of Lesson 4: Event Driven Programming
 Thanks for joining me! I&#8217;ll see you again soon in Lesson 5: Clipping Sprite Sheets</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三节：SDL扩展库]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-3-sdl-extension-libraries/"/>
    <updated>2013-01-28T11:49:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-3-sdl-extension-libraries</id>
    <content type="html"><![CDATA[<p>通过上一节的学习，你也许会怀疑SDL是否能读取BMP以外的图片格式。尽管SDL本身并不提供读取非BMP图片的功能，但包括读取多种图片格式的SDL_image，渲染true-type字体的SDL_ttf，支持更多音乐格式的SDL_mixer，支持网络的SDL
_net，数量庞大而又健壮有力的库扩展着SDL的功能。</p>

<!-- more -->


<p>通过使用这些库，我们可以给我们的程序增加更多功能并使很多事情变得容易许多。在此我们只使用SDL_image，以后的课程中我们会讲到其他的扩展库。</p>

<p> In Lesson 0, when you cloned from the Mercurial and built the libraries you should have also downloaded and built the source for SDL_image, SDL_ttf and SDL_mixer, although I was unable to get SDL_mixer to compile with Visual Studio at the time of writing. This part of the tutorial will be updated when SDL 2.0 is officially released to simply contain links to download the libraries.</p>

<p> If you have not done this, head over to the SDL Mercurial and clone and build the extension libraries available there.</p>

<p> To include the headers and library files on Windows simply paste them in the include and lib directories of your SDL 2.0 folder and add SDL_image.lib and etc. to your linker settings. On Linux following the configure, make, make install pattern will spit out a location where the libraries were installed that you can link against.</p>

<p> In addition to setting up the includes and libraries you will also need to put the dlls that are located in the externals folder along with the dll that was created when building the project. Some dlls are dynamically loaded and as such, only needed if you intend to use their functionality, you may consult the extension library page for the specifics on which dlls behave this way.</p>

<p> In addition to exploring the SDL_image library in this lesson we will also begin to learn about throwing and catching exceptions by adding some error handling to our LoadImage function from last time, instead of checking if the returned pointer was still null. This will allow us to get more information about the exact error that happened and help us track down the cause of the error faster.</p>

<p> For this lesson we will simply be adding some extra stuff to the code we wrote in Lesson 2, so let&#8217;s get that open. IDE users will want to add SDL_image to their linker settings as described above, and for those of you compiling with g++ add -lSDL_image or -lSDL2_image depending on how your 2.0 libraries are named.</p>

<p> We&#8217;ll need to add the extra includes for the new things we want to use, SDL_image and stdexcept.</p>

<p> <div><script src='https://gist.github.com/3139999.js?file=1.cpp'></script>
<noscript><pre><code>#include &quot;SDL.h&quot;</p>

<h1>include &quot;SDL_image.h&quot;</h1>

<h1>include &lt;stdexcept&gt;</h1>

<h1>include &lt;string&gt;</h1>

<h1>include &lt;iostream&gt;</code></pre></noscript></div></h1>

<p> From here we setup as before our screen parameters and create a global window and renderer. If you&#8217;re feeling ill from the use of global objects you may want to take a moment.</p>

<div><script src='https://gist.github.com/3139999.js?file=2.cpp'></script>
<noscript><pre><code>const int SCREEN_WIDTH  = 640;
const int SCREEN_HEIGHT = 480;

SDL_Renderer *renderer = nullptr;
SDL_Window *window = nullptr;</code></pre></noscript></div>


<p> Now let&#8217;s rework our LoadImage function to use SDL_image&#8217;s IMG_LoadTexture to directly load a texture from an image. SDL_image supports many image formats: BMP, GIF, JPEG, LBM, PCX, PNG, PNM, TGA, TIFF, WEBP, XCF, XPM, XV and as such is a very powerful and useful library, as we are no longer limited to the BMP format</p>

<p> Reworking our function is surprisingly simple, we just take out the SDL_Surface business and load the texture directly. Note that we now use IMG_GetError() instead of SDL_GetError(), this is because we&#8217;re now using the SDL_image library to load the image, and as such the appropriate error information would be stored there instead of in SDL.</p>

<div><script src='https://gist.github.com/3139999.js?file=3.cpp'></script>
<noscript><pre><code>SDL_Texture* LoadImage(std::string file){
    SDL_Texture* tex = nullptr;
    tex = IMG_LoadTexture(renderer, file.c_str());
    if (tex == nullptr)
        throw std::runtime_error(&quot;Failed to load image: &quot; + file + IMG_GetError());
    return tex;
}</code></pre></noscript></div>


<p> But we&#8217;ve got one more new thing here. Since we&#8217;ve decided to be smart and add more informative error checking if our image fails to load we will throw a runtime_error which will tell us what happened and more helpfully, which image caused the error. However if you leave this error uncaught when you call the function later in your program and it occurs, it will crash the program. Depending on the situation this may be desirable, but at the moment we&#8217;ll want it to tell us what happened as opposed to just crashing.</p>

<p> We&#8217;re almost ready to draw our images, for this lesson we&#8217;ll be using this image as our background:</p>

<p> and our foreground image will be:</p>

<p> If you look at our foreground image you&#8217;ll notice that it has a transparent background, I&#8217;ve set it like this to demonstrate that IMG_LoadTexture will respect alpha channels and that when the texture is drawn the transparent properties will be retained.</p>

<p> Now that we&#8217;ve got our images we can write our loading code, but recall that we&#8217;ll need to add a try/catch structure to handle the error if one is thrown. Also, don&#8217;t forget to set the file paths to match the image locations on your system.</p>

<div><script src='https://gist.github.com/3139999.js?file=4.cpp'></script>
<noscript><pre><code>    SDL_Texture *background = nullptr, *image = nullptr;
    try {
        background = LoadImage(&quot;../res/Lesson3/background.png&quot;);
        image = LoadImage(&quot;../res/Lesson3/image.png&quot;);
    }
    catch (const std::runtime_error &amp;e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    return 4;
    }</code></pre></noscript></div>


<p> In our catch statement we tell the program to print out e.what(), which will display the string that we put into the runtime_error&#8217;s parentheses. Note that depending on how you&#8217;ve configured your project to build you may not get stdout displayed, if that is the case you can simply write the information to a file instead.</p>

<p> The rest of the code is not shown as it is identical to what was written for Lesson 2, so you can just drop in this new functionality into the old program. If you want to mess with the image positions, feel free to play around. When running the program with the same position settings as Lesson 2 you should see this:</p>

<p> Note that the transparency of the foreground image was preserved. This is a very useful effect as it means we won&#8217;t have to use color keying to cut out the background of our images but instead can use simple transparency. However if you do wish to use color keying, it will be covered in later lessons.</p>

<p> End of Lesson 3: SDL Extension Libraries
 If you have issues compiling or running the code make sure that you&#8217;ve added the include paths and linker settings correctly, along with putting the dlls from SDL_image and its dependencies, located in the externals folder of the source code, into the same folder as your executable.</p>

<p> I&#8217;ll see you again soon in Lesson 4: Event Driven Programming!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第二节：别什么都塞进main里]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-2-dont-put-everything-in-main/"/>
    <updated>2013-01-28T00:46:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-2-dont-put-everything-in-main</id>
    <content type="html"><![CDATA[<p>这一节中，我们将通过编写一些非常有用的函数来将上一节我们所写的代码组织起来，在这之中呢，我们会讨论一下图片是怎样在SDL window中确定位置和缩放的。</p>

<!-- more -->


<p>惯例，我们需要在程序开头包含SDL。这一节我们还需要string类，所以我们在开头也包含它。</p>

<div><script src='https://gist.github.com/3139927.js?file=1.cpp'></script>
<noscript><pre><code>#include &quot;SDL.h&quot;
#include &lt;string&gt;

const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;

SDL_Window *window = nullptr;
SDL_Renderer *renderer = nullptr;</code></pre></noscript></div>


<p>We&#8217;ll also declare some constant values for our screen width and height along with global declarations of a window and renderer so that they&#8217;re accessible by our functions. Again we initialize the pointers as nullptr for safety. If you&#8217;re not using C++11 initialize them as NULL.
我们还声明了一些表示窗口宽度和高度的常量，连同window还有renderer的全局变量，以便于所有的函数都能够访问到它们。这里有一次为了安全我们把指针初始化为nullptr.如果你没有使用C++11，那就把它们初始化为NULL吧。</p>

<p>Note: You should avoid using non-constant global values or global values in general as much as possible, ie. you should never ever declare a global SDL_Window or SDL_Renderer. However, for this simple lesson we&#8217;ll let it slide. But it&#8217;s ok if you feel grossed out. We&#8217;ll cover a solution to global objects in a few lessons.
注意：你应该尽可能地避免适用非常量的全局数或者全局变量，这即是说，你从来都不应该声明全局的SDL_Window和SDL_Renderer。尽管这样，在这个简单的课程中，我们不要纠结这个。但是如果你觉得这样做恶心的话，这也没关系。在以后几节课程中，我们将提到一个解决方案。</p>

<p> Remember from Lesson 1 where we loaded a texture? It wasn&#8217;t so bad to just have it in main for loading one image, but what if we had lots images to load? We&#8217;d have to type it out every time! We can do much better, instead let&#8217;s define a function for loading textures from a filename:
还记得在第一节中我们加载了一个texture么。把加载图像的代码放到main里并不是太坏，但是如果我们需要加载很多图像呢？我们不得不每次都要写一遍那些代码！我们可以做得更好——定义一个可以通过文件名来加载texture的函数。</p>

<div><script src='https://gist.github.com/3139927.js?file=2.cpp'></script>
<noscript><pre><code>SDL_Texture* LoadImage(std::string file){
    SDL_Surface *loadedImage = nullptr;
    SDL_Texture *texture = nullptr;
  
    loadedImage = SDL_LoadBMP(file.c_str());
    if (loadedImage != nullptr){
        texture = SDL_CreateTextureFromSurface(renderer, loadedImage);
        SDL_FreeSurface(loadedImage);
    }
    else
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
    return texture;
}</code></pre></noscript></div>


<p> The function here should look very familiar as it&#8217;s the exact same code we wrote in Lesson 1, but now we have wrapped it up in a nice function. With this function we can pass a file name as a string and get back a pointer to the loaded SDL_Texture. Note that the pointer will be nullptr if the loading fails because we initialize both pointers as nullptr for error checking.
这里的这个函数看起来应该非常眼熟才对，因为它就是我们在第一节写的代码。但是这一次，我们把它们用一个美妙的函数包裹了起来。有了这个函数，我们就可以传给它一个文件名的字符串，然后得到一个SDL_Texture的指针。注意，如果图片加载失败了，这个指针会是nullptr，因为我们为了错误检测，把所有的指针都初始化为了nullptr。</p>

<p> Next we&#8217;ll want to write a function to simplify our draw calls and also allow us to specify a position to draw the image too on the screen. We&#8217;ll want it to be able to take an x, y coordinate position along with a texture pointer and a renderer pointer and then draw the texture to that position.
下一步，我们想要写一个可以简化我们绘制调用，并且允许我们指定图像在屏幕上绘制的位置的函数。我们需要它能够取得x, y坐标位置还有一个texture指针，以及一个renderer指针，然后把那个texture画在那个位置。</p>

<div><script src='https://gist.github.com/3139927.js?file=3.cpp'></script>
<noscript><pre><code>void ApplySurface(int x, int y, SDL_Texture *tex, SDL_Renderer *rend){
    SDL_Rect pos;
    pos.x = x;
    pos.y = y;
    SDL_QueryTexture(tex, NULL, NULL, &amp;pos.w, &amp;pos.h);
 
    SDL_RenderCopy(rend, tex, NULL, &amp;pos);
}</code></pre></noscript></div>


<p> In order to specify a position for the texture to be drawn too we need to create a SDL_Rect that we can pass the address to SDL_RenderCopy&#8217;s destination rect parameter. This is done because the last two parameters of SDL_RenderCopy are SDL_Rect pointers, so it&#8217;s expecting an address.
为了指定Texture绘制的位置，我们需要创建一个SDL_Rect，这样我们就可以把它的地址传给SDL_RenderCopy的目标rect参数。这样做是因为SDL_RenderCopy的最后两个参数是SDL_Rect类型的指针，所以需要传入一个地址。</p>

<p>To create our rectangle we take the x and y values that we passed in and the set rectangle&#8217;s values equal to them. However we must also specify the width and height we want the texture to be drawn with as SDL 2.0 also gives us the ability to scale our textures. Try playing with the width and height values once the tutorial is done and see what happens!
为了创建这个矩形（rectangle），我们将传入的x与y赋给rectangle的x和y.另外，我们还必须指定需要texture绘制的宽度和高度，因为SDL2.0在这里赋予了我们缩放texture的能力。在本教程结束后，你可以试着更改高度和宽度并看看会发生什么情况。
For now we just want to pass the texture&#8217;s width and height so that we draw it at a 1:1 scale. We can get these values by using SDL_QueryTexture. This function takes the texture pointer we want to query, the two parameters we pass NULL to are the format and access level parameters respectively, which we can ignore. Finally we must pass the addresses of the variables that we want to fill with the width and height of the texture.
但是现在我们只想把texture原本的宽度和高度传入，以便于以1：1的比例来绘制它。我们可以通过SDL_QueryTexure来获取这些值。这个函数需要我们传入texture的指针，后面两个参数我们传入NULL，它们分别是texture格式（? 待考证函数说明）和访问级别，现在我们可以无视它们。最后我们将需要填texture宽高的变量的地址传入。
 Now that we&#8217;ve got our SDL_Rect set up we can pass it, along with the renderer and texture as before, to SDL_RenderCopy so that our texture will be drawn at the point specified and with its original width and height. The remaining NULL parameter in this function is for taking a clip of the source texture, which we&#8217;ll cover later.
现在我们已经有了SDL_Rect，我们可以把它还有renderer，以及之前的texture传给SDL_RenderCopy ，这样texture就会以它原始的尺寸绘制在我们制定的位置。剩下的那个NULL的参数是为了裁剪原来的texture只用的，这点我们会在后面提及。
 Let&#8217;s see our functions in action. First we&#8217;ve got to start up SDL and create our window and renderer as before. We&#8217;ve also got something new here, SDL_WINDOWPOS_CENTERED. This is an option we can use when creating our window to tell SDL to center its position on the specified axis, here we do it for x and y.
现在我们实际看一下我们的函数。首先我们和以前一样开启SDL，创建窗口还有renderer。这里还有个新东西，SDL_WINDOWPOS_CENTERED.这是个可以用来在创建窗口的时候告诉SDL把窗口设到指定坐标轴中央的选项，这里我们指定的是x和y。</p>

<div><script src='https://gist.github.com/3139927.js?file=4.cpp'></script>
<noscript><pre><code>int main(int argc, char** argv){
    if (SDL_Init(SDL_INIT_EVERYTHING) == -1){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }
 
    window = SDL_CreateWindow(&quot;Lesson 2&quot;, SDL_WINDOWPOS_CENTERED, 
        SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
    if (window == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 2;
    }
    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED 
        | SDL_RENDERER_PRESENTVSYNC);
    if (renderer == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 3;
    }</code></pre></noscript></div>


<p> Now let&#8217;s load up our images. For this lesson we&#8217;ll be drawing a tiled background image and drawing a centered image on top of it. Here&#8217;s our background:
现在我们加载图片。本节我们将绘制一个平铺的背景图还有位于它上面的一张居中的图。张是我们的背景图：</p>

<p><img src="https://raw.github.com/Twinklebear/TwinklebearDev-Lessons/master/res/Lesson2/background.bmp"></p>

<p>And this will be our foreground image:
然后这张是前景图：</p>

<p><img src="https://raw.github.com/Twinklebear/TwinklebearDev-Lessons/master/res/Lesson2/image.bmp"></p>

<p>Let&#8217;s load them up with the LoadImage function we just wrote.
我们用刚才写的LoadImage 函数来加载它。</p>

<div><script src='https://gist.github.com/3139927.js?file=5.cpp'></script>
<noscript><pre><code>    SDL_Texture *background = nullptr, *image = nullptr;
    background = LoadImage(&quot;Lesson2res/background.bmp&quot;);
    image = LoadImage(&quot;Lesson2res/image.bmp&quot;);
    if (background == nullptr || image == nullptr)
        return 4;</code></pre></noscript></div>


<p> Note that you will have to change the file paths to match the relative location of the image to the executable on your system.
注意你也许需要更改文件路径以便与文件实际运行的路径匹配。
 Before we draw the images we&#8217;ll need to know where we want to position them, specifically how we&#8217;ll tile our background and also how we can draw the foreground image centered on the screen. First we&#8217;ll have to understand how SDL&#8217;s coordinate system works, as it is a bit different than the standard 2D Cartesian coordinate system. SDL&#8217;s coordinate system looks like this:
在绘制图片之前，我们需要知道我们要把它们放在那里，特别是我们应该如何平铺背图，还有如何把前景图绘制在屏幕中央。首先，我们必须弄明白SDL的坐标系统是怎样工作的。SDL的坐标系统看起来是这样的：
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/lesson2/sdlcoord.png">
With 0, 0 being in the top-left corner of the screen. Y values increase as we move down the screen and X values increase as we move to the right on the screen. Another thing to note about SDL&#8217;s coordinate system is that the x, y point specified to draw an image at is used as the location to draw the top-left corner of the image, as opposed to the center of the image like some other libraries.
坐标0,0处从屏幕左上角开始。Y坐标从上到下增加，X坐标从左到右增加。另外还有一个需要注意的问题，SDL的坐标系统是，指定的图片绘制的x,y坐标，将以这个坐标为图片左上角的坐标来绘制——而不是像其他一些库一样把这个坐标当作图片的中心。</p>

<p>Before we draw: A note about SDL&#8217;s drawing order: The order in which things are drawn will be the order in which they sit on top of each other, so the first thing drawn is the bottom-most image, and the last image drawn will sit on top of everything.</p>

<p>在绘制之前，还有一个需要注意的问题：SDL的绘制顺序。我们绘制时的顺序就是图像叠加的顺序，所以我们首先绘制的东西将位于最底层，最后绘制的将位于所有图像的最上层。</p>

<p> If you&#8217;ve taken a peek at the background image yet you&#8217;ll have noticed that it has a width of 320 and a height of 240, with a screen that is 640x280 we&#8217;ll need to draw the background image four times to tile it over the window scooting it over by its width or height each time.
如果你看了那张背景图，你会发现这张图长320宽240，如果是640x480的屏幕的话，我们需要把它画四次以覆盖整个窗口，每次都要依据图片长宽来移动图片。
 Before drawing anything, we&#8217;ll want to clear the screen, next we&#8217;ll want to setup the positioning of elements on the window. We can get the width and height of the image again by using the QueryTexture function on the background, this gives us a more versatile method in which we could instead create a for loop to iterate over the positions based on the image width and height, perhaps if we were placing many small tiles. For this case we&#8217;re only drawing it four times, so we can take the &#8216;dumb&#8217; route and just type it out.
在绘制之前，我们需要清屏，然后创建好需要画到窗口中的元素。我们可以通过QueryTexture函数来获取背景图的长和宽，它为我们提供了相较之用一个for循环来迭代图像的长宽的一个更便捷的方法，如果我们需要绘制很多小的tile（方块？就是2D游戏中常见的一张图储存了很多种方块，方块的不同排列组成场景的不同部分。。。的那种方块。= =||）因此，我们只需要画四次，因此，我们可以采取&#8217;哑巴&#8217;的路线，只需键入它。(我承认后半句是google翻译姬= =)</p>

<div><script src='https://gist.github.com/3139927.js?file=6.cpp'></script>
<noscript><pre><code>    SDL_RenderClear(renderer);

    int bW, bH;
    SDL_QueryTexture(background, NULL, NULL, &amp;bW, &amp;bH);
    ApplySurface(0, 0, background, renderer);
    ApplySurface(bW, 0, background, renderer);
    ApplySurface(0, bH, background, renderer);
    ApplySurface(bW, bH, background, renderer);</code></pre></noscript></div>


<p> Now we want to draw our foreground image on top of the background, and centered in the window. We can calculate the center point quite easily but because the point we pass to ApplySurface is the location of the top-left corner of the image we must also apply an offset to the point relative to the image&#8217;s width for x and height for y to put the real center of the image at the center point of the screen.
现在，我们想要把前景图画在背景图上方并在窗口中居中显示。我们可以很容易地计算出中间点的坐标，但是因为传入ApplySurface函数的图片坐标应该在图片左上角，我们必须给这个点应用一个基于原图像宽度和高度的偏移，以把图片正确地放到屏幕中央。</p>

<div><script src='https://gist.github.com/3139927.js?file=7.cpp'></script>
<noscript><pre><code>    int iW, iH;
    SDL_QueryTexture(image, NULL, NULL, &amp;iW, &amp;iH);
    int x = SCREEN_WIDTH / 2 - iW / 2;
    int y = SCREEN_HEIGHT / 2 - iH / 2;
    ApplySurface(x, y, image, renderer);</code></pre></noscript></div>


<p> In order to see our drawing we&#8217;ll have to present the renderer and then have SDL wait for a second or two so we have a chance to see the image.
为了看到我们绘制的结果，我们需要把renderer呈现（present）出来，并且让SDL等待一两秒钟以便于我们能看到显示的图像。</p>

<div><script src='https://gist.github.com/3139927.js?file=8.cpp'></script>
<noscript><pre><code>    SDL_RenderPresent(renderer);
    SDL_Delay(2000);</code></pre></noscript></div>


<p> Finally, we wrap up the program by freeing the memory being used by the textures, renderer and window, quit SDL and return.
最后，我们为了圆满地结束这个程序，需要释放掉texture、renderer还有window所占用的内存，退出SDL并返回。</p>

<div><script src='https://gist.github.com/3139927.js?file=9.cpp'></script>
<noscript><pre><code>    SDL_DestroyTexture(background);
    SDL_DestroyTexture(image);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
 
    SDL_Quit();
  
    return 0;
}</code></pre></noscript></div>


<p> When you compile and run the program your window should look like this:
当你编译并运行了这个程序，你的窗口看起来应该这样的：
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/lesson2/Lesson2_Result.png"></p>

<p> Lesson 2 Extra Challenge!
 Find a way to convert our dumb method of tiling the background into a lean mean for loop! While it may not be so effecient for four background tiles, using a for loop for tiling is a very nice method for placing a large amount of tiles.
 Hint
第二节的额外挑战！</p>

<p> End of Lesson 2: Don&#8217;t Put Everything in Main
 If you have trouble compiling or running the program make sure you&#8217;ve set up the includes, include directories, linker settings and linker directories correctly, along with setting the correct path to the images and placing the SDL.dll in your executable folder. For Linux users there is no SDL.dll but instead make sure you have the runtime libraries in the correct place in your system.</p>

<p> I&#8217;ll see you again soon in Lesson 3: SDL Extension Libraries!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一节: Hello World!]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/lesson-1-hello-world/"/>
    <updated>2013-01-26T20:22:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/lesson-1-hello-world</id>
    <content type="html"><![CDATA[<p>这一节我们将学习将一张图片绘制到屏幕上的简单方法。具体来讲是绘制下面这张图片。</p>

<!-- more -->


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/hello.bmp">
你可以通过右键另存为下载这张图片。<del>这是一个指向一个我建立的Github版本库里的图片的链接，因为这样做会保存一个SDL能够加载的真正的BMP图片。 </del>这个版本库同时也是我教程中例子的源代码和其他相关资源（assets）的主页。如果你丢了资源或者想要偷看一下我的代码，就从<a href = "https://github.com/Twinklebear/TwinklebearDev-Lessons">这里</a>抓好了。但是，不要复制粘贴！</p>

<p>第一步总是include SDL的头文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "SDL.h"</span></code></pre></td></tr></table></div></figure>


<p>注意，这依赖于你的SDL设置。对Linux用户来说，也许需要这样做：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "SDL/SDL.h"
</span><span class='line'>//or
</span><span class='line'>#include "SDL2/SDL.h"
</span><span class='line'>//depending on your configuration</span></code></pre></td></tr></table></div></figure>


<p>——除非你在编译选项里指定了头文件的绝对路径（对linux用户来说）。</p>

<p>首先我们需要启动SDL以便使用它。注意：如果SDL初始化失败的话，它会返回-1。这样的情况下，我们可以使用SDL_GetError()函数来输出错误消息，然后退出程序。</p>

<p>对Visual Studio用户的特殊说明：如果你在连接器选项中把子系统设置为了windows，你将不会看到输出到控制台的结果。要获得这个结果，你必须把子系统改为“未设置”并且把#undef main放到main函数前面。当改回windows子系统的时候，你要确认一下你把#undef main这行代码去掉了，否则你会得到链接错误。</p>

<div><script src='https://gist.github.com/3139888.js?file=a.cpp'></script>
<noscript><pre><code>int main(int argc, char** argv){
    if (SDL_Init(SDL_INIT_EVERYTHING) == -1){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>然后我们还需要创建一个能让我们绘制图像的窗口，我们可以使用SDL_Window:</p>

<div><script src='https://gist.github.com/3139888.js?file=b.cpp'></script>
<noscript><pre><code>    SDL_Window *win = nullptr;
    win = SDL_CreateWindow(&quot;Hello World!&quot;, 100, 100, 640, 480, SDL_WINDOW_SHOWN);
    if (win == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>SDL_CreateWindow这个函数的作用是为我们创建一个窗口，并且返回一个SDL_Window指针。这个函数的第一个参数是窗口的标题，之后是窗口所打开的位置的x,y坐标，之后的参数是窗口的长度和宽度。最后一个参数是窗口的各种flag，因为我们想要窗口在创建之后马上弹出，所以这里我们填SDL_WINDOW_SHOWN。</p>

<p>我们也提供了一些错误安全保障，把指针初始化为了nullptr，并在创建了窗口之后，检查了这个指针是否仍为空。如果创建窗口失败了，这个指针将仍然是空的，这样我们就需要中止这个程序。把指针初始化为空NULL总是很重要的，或者也可以利用C++ 11新标准把它初始化为nullptr。</p>

<p>现在，仅仅只是打开一个窗口对我们来说意义不大，我们需要把东西画到窗口上。所以现在让我们获取一个SDL_Renderer并且运行吧。</p>

<div><script src='https://gist.github.com/3139888.js?file=c.cpp'></script>
<noscript><pre><code>    SDL_Renderer *ren = nullptr;
    ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (ren == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>我们的renderer（渲染器）是用SDL_CreateRenderer这个函数创建的，这个函数还需要我们指定用来绘制的窗口。我们也可以指定一个可选的显卡驱动，或者直接把参数设为-1，好让SDL自动选择适合我们指定的选项的驱动。这样做可能是最好的选择，因为这会让SDL为你选择你所需要的——也就是你在最后一个参数中用那些标志指定的——合适的驱动。</p>

<p>在这里我们指定了SDL_RENDERER_ACCELERATED，因为我们想使用硬件加速的renderer，换句话说就是想利用显卡的力量。我们还指定了 SDL_RENDERER_PRESENTVSYNC标志，因为我们想要使用SDL_RendererPresent这个函数，这个函数将会以显示器的刷新率来更新画面。</p>

<p>注意，在这里我们使用了和之前创建窗口时一样的错误处理方式。</p>

<p>现在是时候加载一张图片并把它画到屏幕上啦！你应该已经把这张图片下载到同一个文件夹下了，或者把这张图放在你生成的可执行文件附近也是可以的。</p>

<p>尽管SDL2.0使用SDL_Texture来用硬件加速绘制图像，我们还是需要使用SDL_LoadBMP函数将图片加载到SDL_Surface中，因为本节我们没有使用SDL_image这个神奇的扩展库（我们以后会用到的）。</p>

<div><script src='https://gist.github.com/3139888.js?file=d.cpp'></script>
<noscript><pre><code>    SDL_Surface *bmp = nullptr;
    bmp = SDL_LoadBMP(&quot;../res/Lesson1/hello.bmp&quot;);
    if (bmp == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>注意在这里你需要更改传给SDL_LoadBMP的图片路径，以便和你电脑上的图片路径匹配。或者如果你想使用我现在这样的文件结构的话，你也可以保持这个参数原来的样子而不改动。</p>

<p>要有效地利用硬件加速来绘制，我们必须把SDL_Surface转化为SDL_Texture，这样renderer才能够绘制。</p>

<div><script src='https://gist.github.com/3139888.js?file=e.cpp'></script>
<noscript><pre><code>    SDL_Texture *tex = nullptr;
    tex = SDL_CreateTextureFromSurface(ren, bmp);
    SDL_FreeSurface(bmp);</code></pre></noscript></div>


<p>在这里我们也把刚才的SDL_Surface释放掉，因为以后就用不着它了。</p>

<p>现在我们可以把Texture画到renderer上了。首先，我们先使用SDL_RenderClear来清空屏幕，然后我们使用SDL_RenderCopy来把texture画上去。最后，我们使用SDL_RenderPresent来更新屏幕的画面。</p>

<div><script src='https://gist.github.com/3139888.js?file=f.cpp'></script>
<noscript><pre><code>    SDL_RenderClear(ren);
    SDL_RenderCopy(ren, tex, NULL, NULL);
    SDL_RenderPresent(ren);</code></pre></noscript></div>


<p>这里我们给SDL_RenderCopy传了两个NULL值。第一个NULL是一个指向源矩形的指针，也就是说，从图像上裁剪下的一块矩形；而另一个是指向目标矩形的指针。我们将NULL传入这两个参数，是告诉SDL绘制整个源图像（第一个NULL），并把它画在屏幕上（0，0 ）的位置，并拉伸这个图像让它填满整个窗口（第二个NULL）。这一点以后还会详细说明。</p>

<p>我们还用SDL_Delay告诉程序让它等2000毫秒，以便于我们可以看到这个窗口。不让它等待的话，这个窗口就会在弹出之后立刻退出程序。</p>

<div><script src='https://gist.github.com/3139888.js?file=g.cpp'></script>
<noscript><pre><code>    SDL_Delay(2000);</code></pre></noscript></div>


<p>在我们退出程序之前，我们有必要释放掉我们这个窗口、renderer还有texture所用的全部内存。这可以通过调用几个SDL_Destroy来完成。</p>

<div><script src='https://gist.github.com/3139888.js?file=h.cpp'></script>
<noscript><pre><code>    SDL_DestroyTexture(tex);
    SDL_DestroyRenderer(ren);
    SDL_DestroyWindow(win);</code></pre></noscript></div>


<p>退出SDL以停止程序，并且返回0.</p>

<div><script src='https://gist.github.com/3139888.js?file=i.cpp'></script>
<noscript><pre><code>    SDL_Quit();
    return 0;
}</code></pre></noscript></div>


<p>编译并检查这个程序吧！不要忘了把SDL.dll放到你的可执行文件的文件夹里，否则你会得到一个弹出的错误提示。如果你用的是linux系统，你应该已经安装了SDL的共享库了，所以你应该不会遇到什么问题。</p>

<p>现在，恭喜你写出第一个SDL2.0程序！</p>

<p> Troubleshooting
 If your program fails to compile make sure you&#8217;ve properly configured your libraries and linked to the correct path in your include statement.</p>

<p> If your program complains about SDL.dll missing, make sure it is located in the same folder as the executable.</p>

<p> If your program runs but exits with out displaying anything make sure your image path is set correctly. If that doesn&#8217;t help try writing some cout or file output into the program, although depending on your platform and configuration settings cout may not appear.</p>

<p>第一节结束。</p>

<p>这就是第一节了。我们第二节：别把什么都放到main里再见吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译SDL2.0教程】在Visual Studio中配置SDL]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/setting-up-sdl-in-visual-studio/"/>
    <updated>2013-01-26T13:34:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/setting-up-sdl-in-visual-studio</id>
    <content type="html"><![CDATA[<p>既然我们已经把库配置好了，我们就需要在我们的项目中链接SDL库。打开Visual Studio，创建一个新的空白C++工程。<br></p>

<!-- more -->


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setruntimelib.png" title="新建工程" alt="新建工程" /><br>
要让工程识别SDL的头文件和库文件，我们需要编辑几项简单的与包含路径和链接设置有关的选项。
右键单击项目名，打开属性菜单。在C/C++列表下，选择“常规”，然后单击最上面的“附加包含目录”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/settingincludedir.png" title="设置包含目录" alt="设置包含目录" /><br>
选择&#8221;编辑&#8221;。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/additionalincludedir.png" title="附加包含目录" alt="附加包含目录" /><br>
单击“新行”图标增加一行，然后单击文本框右面的浏览按钮（三个点的那个），找到你的SDL文件夹，在其中选择“include”文件夹。点“选择文件夹”，确定并应用以保存你的设置。
下一步我们需要更改运行库。在C/C++列表下，选择“代码生成”，然后找到“运行库”项，把它改为“多线程 DLL (/MD)”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setruntimelib.png" title="运行库" alt="运行库" /><br>
要把库链接上，选择C/c++下面的“连接器（linker）”,选择“常规”，然后点击窗口中间的“附加库目录”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/settinglinkerdir.png" title="链接目录" alt="链接目录" /><br>
和之前一样，点击文本框右侧的朝下的三角箭头按钮，选择编辑。
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/additionallibdir.png" title="附加库目录" alt="附加库目录" /><br>
再一次选择新建，单击浏览按钮。找到你的SDL文件夹，打开lib文件夹，你会看到两个文件夹，32位的x86和64位的x64。你可以任选其一，但是你必须明白VC++默认是编译的32位
程序，你可能需要更改其他设置。在这个教程中，我选择的是x86。点击选择，确认，应用来保存你的设置。<br>
下一步我们必须指定我们将要链接的库文件。于是在连接器菜单里，选择“输入”菜单，点击“附加依赖项”文本框，像之前一样点击右面的三角箭头并选择“编辑”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/settinglibinput.png" title="附加依赖项" alt="附加依赖项" /><br>
要让VC++知道我们想要使用的库，填入</p>

<pre><code>SDL.lib; SDLmain.lib;
</code></pre>


<br>


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setadditiondep.png" title="附加依赖项" alt="附加依赖项" /><br>
点击确认，应用来保存设置。
随后一步是将子系统目标改为windows。选择连接器下的“系统”菜单，将“子系统”条目改为Windows。</p>

<br>


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setsubsystem.png" title="setsubsystem" alt="setsubsystem" /><br>
点击应用，以保存设置，确认关闭窗口。</p>

<br>


<p>现在我们来测试一下我们的配置是否正确。给工程添加一个C++源文件并输入：</p>

<script src="https://gist.github.com/3139836.js"></script>


<p>这段简单的代码将初始化SDL，然后退出。你不会看到任何事发生。尝试编译这个项目，如果有错误提示的话，确认你没有跳过之前任何一步，并确认你是否选择了正确的文件夹。在运行这段代码之前，你应该把SDL路径下，bin文件夹内的动态链接库SDL.dll放到项目可执行文件的文件夹里。否则的话，程序将会运行失败并弹出找不到SDL的错误。<br>
作为最后一件为以后每次创建SDL项目省下麻烦的额外工作，你可以把这个项目导出为一个模板。选择文件菜单然后点击导出模板，然后把它导出为项目模板。你可以给它取个名字也可以为它增加任意你喜欢的描述。现在当我们创建一个新的SDL项目的时候，你只需要选择这个模板，只要你的SDL文件夹没有移动，那么所有的东西都被设置好了。
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/exporttemplate.png" title="exporttemplate" alt="exporttemplate" /><br></p>

<br>


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/sdltemplate.png" title="sdltemplate" alt="sdltemplate" /><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译SDL2.0教程】第0节：配置SDL]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/lesson-0-setting-up-sdl/"/>
    <updated>2013-01-25T23:28:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/lesson-0-setting-up-sdl</id>
    <content type="html"><![CDATA[<p>  <h3>
SDL2.0说明</h3>
截至到2012年6月17日我写这篇帖子为止，SDL2.0还没有发布官方正式版本，因此你需要用你所用的编辑器自行编译。</p>

<!-- more -->


<p>  <br>
  <br>
  你可以在<a href="http://www.libsdl.org/hg.php">这里</a>下载它。
  <br>
  <br>
你可以从Mecurial版本库里clone一份最新的源码，但下载一份快照也是个不错的选择。在实际写代码的时候，需要clone他们的Mercurial版本库来下载我们要用到的扩展库。
  <br>
  <br>
在下载完之后，就很容易设置了。注意扩展库SDL_image, SDL_ttf还有SDL_mixer是依赖于SDL的，你需要指定包含路径和链接设置来编译，其中SDL要先编译。</p>

<p>  <br>
  <br>
注意源码文件夹里已经包含了怎样在各个平台上编译构建的文档说明，它们应该能够帮你构建并确认一切是否正常，你也可以继续阅读。
  <br>
  <br>
SDL2.0发布官方正式版时，我会更新链接，这样你们就可以直接下载编译好的库，这就更容易了。
  <br>
  <br>
  <h3>
C++11说明</h3>
在这个教程中，我们会使用一些C++11新标准中的特性，因此你可以选择使用支持这些新标准的编译器，也可以把这些代码翻译成你所使用的编译器所支持的代码，这不会太痛苦。Visual Studio 2012支持C++11,如果你用的是GCC，你可以通过增加-std=c++0x的编译选项来启用C++11特性。</p>

<p>  <br>
  <br>
  <h3></p>

<p>Visual Studio</h3>
源码文件夹里应该包含了一个叫VisualC的文件夹，如果你打开项目解决方案时被提示更新项目，照做就是。在构建之前，确定你选择生成的是Release版本。这样解决方案应该会顺利生成。主目录里有一个VisualC.html文件，里面包含的信息如果你在编译出问题的时候应该很有用。
  <br>
<em>译注：在windows下编译需要安装DirectX SDK</em>
  <br></p>

<p>在生成扩展库的时候，确认你生成的是Release版本。注意在你编译之前，你需要指定SDL2.0的包含路径(include directory，头文件路径)和库路径(library directory)。
  <br>
  <br>
  <b>SDL_mixer的说明：</b>
很不幸我没能在Visual Studio中生成SDL_mixer，尽管它能在Linux里正常使用。所以我觉得Visual Studio的工程文件有点问题。
  <br>
  <br>
当你全部生成完所有的库之后，你要把头文件，lib库文件还有dll放到你不会忘得地方，因为我们会在我们的项目中使用到这些文件。我的路径是C:\
  <br>
  <br>
  <a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/setting-up-sdl-in-visual-studio/">这里</a>有如何创建你第一个SDL项目的教程。
  <br>
  <br>
  <h3>
Linux </h3>
Linux用户只需要使用标准的configure,make,make install.注意要记下你的头文件和库文件的安装路径，因为你在之后编译项目的时候需要指定这些路径。另外你也可以把库和头文件移到标准路径下。你可以把运行库放到或者链接到/lib/路径下，或者放到其他存放运行库的备用路径下面。
  <br>
  <br></p>

<p>关于Linux里编译命令的教程在
  <a href="http://twinklebeardev.blogspot.com/2012/07/setting-up-sdl-on-linux-command-line.html">这里</a>。
  .
  <br>
  <br>
  <h3></p>

<p>Mac</h3></p>

<p>源代码文件夹还包含了一个XCode的工程，但我没有Mac电脑所以很不幸我无法提供更多的指导。在源码中包含的文档里查找关于构建这些库以及如何包含头文件和库文件的信息吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译SDL2.0教程】目录]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/sdl-2-dot-0-tutorial-index/"/>
    <updated>2013-01-25T23:12:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/sdl-2-dot-0-tutorial-index</id>
    <content type="html"><![CDATA[<p>原文地址:<a href = "http://twinklebeardev.blogspot.com/p/sdl-20-tutorial-index.html">SDL 2.0 Tutorial Index</a></p>

<h3>Welcome!</h3>


<p>下面的教程目的是为你提供一个关于SDL2.0以及c++中游戏设计主题和概念的介绍。在本教程中，我们假定你对C++有一定程度上的知识，至少了解数组，vector，控制结构，函数还有指针。<br /><br />
如果你觉得理解教程中的代码有困难，你可以在教程后面随意留言，或者在<a href="http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">StackOverflow</a>上的这个列表里抓一本书来读。<br /><br />
如果你想要查看或者下载全部的程序代码，你可以在<a href="https://github.com/Twinklebear/TwinklebearDev-Lessons">Github</a>上下载到。但是不要复制！<br /><br />
SDL2.0的文档现在可以在<a href="http://wiki.libsdl.org/moin.cgi/FrontPage">online wiki</a>上查看到。<br /><br /></p>

<h3>教程目录：</h3>


<p><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-0-setting-up-sdl.html"><b>Lesson 0: Setting up SDL</b></a>&nbsp;<a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/lesson-0-setting-up-sdl/">第0节：配置SDL</a> <br />
<a href="http://twinklebeardev.blogspot.com/2012/07/lesson-1-hello-world.html"><b>Lesson 1: Hello World!</b></a>&nbsp;<a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/lesson-1-hello-world/">第一节: Hello World!</a> <br />
<a href="http://twinklebeardev.blogspot.com/2012/07/lesson-2-dont-put-everything-in-main.html"><b>Lesson 2: Don&#8217;t Put Everything in Main</b></a>&nbsp;<a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-2-dont-put-everything-in-main/">第二节：别什么都塞进main里</a> <br />
<b><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-3-sdl-extension-libraries.html">Lesson 3: SDL Extension Libraries&nbsp;</a></b><br />
<b><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-4-event-driven-programming.html">Lesson 4: Event Driven Programming</a></b><br />
<a href="http://twinklebeardev.blogspot.com/2012/08/lesson-5-clipping-sprite-sheets.html"><b>Lesson 5: Clipping Sprite Sheets&nbsp;&nbsp;</b></a><br />
<a href="http://twinklebeardev.blogspot.com/2012/08/lesson-6-true-type-fonts-with-sdlttf.html"><b>Lesson 6: True Type Fonts with SDL_ttf</b></a><br />
<b><a href="http://twinklebeardev.blogspot.com/2012/09/lesson-7-taking-advantage-of-classes.html">Lesson 7: Taking Advantage of Classes</a></b><br />
<a href="http://twinklebeardev.blogspot.com/2012/10/lesson-8-timers.html"><b>Lesson 8: Timers </b></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello world]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/hello-world/"/>
    <updated>2013-01-25T21:16:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/hello-world</id>
    <content type="html"><![CDATA[<p>这是一个测试。</p>

<pre><code>这是一个代码区块。
</code></pre>

]]></content>
  </entry>
  
</feed>
