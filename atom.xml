<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[SDL中文教程]]></title>
  <link href="http://adolfans.github.com/sdltutorialcn/atom.xml" rel="self"/>
  <link href="http://adolfans.github.com/sdltutorialcn/"/>
  <updated>2013-02-13T01:41:11+08:00</updated>
  <id>http://adolfans.github.com/sdltutorialcn/</id>
  <author>
    <name><![CDATA[Adolfans]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[第八节：定时器]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-8-timers/"/>
    <updated>2013-01-28T12:17:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-8-timers</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第七节：充分利用类]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-7-taking-advantage-of-classes/"/>
    <updated>2013-01-28T12:17:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-7-taking-advantage-of-classes</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第六节: 使用SDL_ttf绘制True Type字体]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-6-true-type-fonts-with-sdl-ttf/"/>
    <updated>2013-01-28T12:16:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-6-true-type-fonts-with-sdl-ttf</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第五节：裁剪精灵表]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-5-clipping-sprite-sheets/"/>
    <updated>2013-01-28T12:16:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-5-clipping-sprite-sheets</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第四节：事件驱动的编程]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-4-event-driven-programming/"/>
    <updated>2013-01-28T12:15:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-4-event-driven-programming</id>
    <content type="html"><![CDATA[<p>Now that we&#8217;ve learned how to draw images to the screen it&#8217;s time to learn how to read user input. Our game won&#8217;t be very good if there&#8217;s no way to play it! In this lesson we will cover simple event handling using SDL and begin designing a primitive &#8216;main loop&#8217;.</p>

<!-- more -->


<p> Before we begin it&#8217;s important to mention that the majority of the code being used for this lesson is the code that we&#8217;ve built up from previous lessons, and as such the repeated code will not be shown as it is assumed you have it already and  are using what you&#8217;re learning here to add on to the previous lesson&#8217;s code. If you don&#8217;t have the code, head back to the earlier lessons, or if you already understand the material grab the code from Lesson 3 off Github and let&#8217;s get started modifying it.</p>

<p> We&#8217;ll create the renderer and window the same as before, and our LoadImage and ApplySurface functions remain unchanged. The first change to our program is the loading of a different image, note that you will need to change the filepath to match the location of the image relative to the executable on your system, or the program will fail to run.</p>

<div><script src='https://gist.github.com/3161759.js?file=1.cpp'></script>
<noscript><pre><code>//In main...
    SDL_Texture *image = nullptr;
    try {
        image = LoadImage(&quot;../res/Lesson4/image.png&quot;);
    }
    catch (const std::runtime_error &amp;e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        return 4;
    }
    int iW, iH;
    SDL_QueryTexture(image, NULL, NULL, &amp;iW, &amp;iH);
    int x = SCREEN_WIDTH / 2 - iW / 2;
    int y = SCREEN_HEIGHT / 2 - iH / 2;</code></pre></noscript></div>


<p>We also use the same equation as before for centering our image in the window. For this lesson our image will be:</p>

<p><img src="https://github.com/Twinklebear/TwinklebearDev-Lessons/blob/master/res/Lesson4/image.png"></p>

<p> Now before we dive into writing our main loop and event handling code, we&#8217;ll want to get an understanding of how the SDL event system works.</p>

<p> An event is any interaction with the program done by the user: keypresses, mouse motion, mouse presses, joystick movement, window resizing, minimizing or closing, etc. SDL provides a structure for storing these events called SDL_Event. Let&#8217;s create one now.
 Whenever an event occurs it&#8217;s added to a stack in chronological order. If we want to read an event from this stack we can pull the oldest event using SDL_PollEvent. This may be a bit confusing, hopefully this handy graphic will help make it a bit clearer.
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/lesson4/evntstack.png">
 So in this case the user resized the window, then clicked the mouse, then pushed a key. When we call SDL_PollEvent on this queue it will get the event that happened first, or the oldest event, and put it into our SDL_Event structure so that we can look at the event data in our program.</p>

<p> So if each frame of our game we want to process all events in the queue we&#8217;ll want to loop through until there&#8217;s nothing left to read, then continue on and do our other stuff like logic and rendering. This is starting to sound like something we could call our main loop!</p>

<p> In each iteration of the loop we&#8217;ll want to process our event queue, do some program logic and draw the frame and then do it all over again until the user quits.</p>

<div><script src='https://gist.github.com/3161759.js?file=2.cpp'></script>
<noscript><pre><code>    SDL_Event e;</code></pre></noscript></div>


<p> Next we&#8217;ll want to do our event polling. Our goal was to run over all the events in the queue each frame, so let&#8217;s use another while loop, as PollEvent will return 1, &#8216;true&#8217;, if there are any pending events, so our loop will run until there are no more events in the queue.
 First we get an event from the queue with SDL_PollEvent, which we pass an address too as its signature is SDL_PollEvent(SDL_Event*) and then we do whatever we want to with the input. In this case we&#8217;re just going to quit the program if the user pushes any key, clicks the mouse or closes the window, so if just about anything happens we set quit to true. Note that clicking the X on the window is read as SDL_QUIT.</p>

<p> SDL&#8217;s event structure is able to read many different types of events and provides all the valid information tied to each event that may be needed in deciding what to do with the input. For more information on the various event types and the data that comes with them, check out the SDL_Event documentation.</p>

<p> The next step in our loop would be to do various calculations that our program needs to do, such as determining movement, collision outcomes and etc. However since our program is very primitive we don&#8217;t need to do any logic at the moment, so we&#8217;ll continue on to rendering.
 The code is identical to before, but we must be sure each time to clear the screen before drawing our new scene or we could have images left over from previous frames start showing up.</p>

<p> You&#8217;ll want to wrap up the program by destroying the texture, renderer and window and quit SDL.</p>

<p> When you run the program you should be able to quit by clicking the X on the window, clicking in the window or pressing a key while the window is selected. You may also notice something a bit interesting when running the program if you check its CPU usage. If you&#8217;ve seen tutorials where the main loop is discussed or have written SDL1.2 code you&#8217;d expect that our program for this lesson would max out one of your CPU cores because there&#8217;s no framerate limiting being done. This is no longer the case with our program as we have created our renderer with the SDL_PRESENTVSYNC flag which tells the renderer to delay and match the framerate of our monitor, letting SDL take care of the framerate limiting for us, and letting us skip writing a line or two of code.</p>

<p> Lesson 4 Extra Challenge!
 Try getting the image to move on the screen.
 Hint</p>

<p> End of Lesson 4: Event Driven Programming
 Thanks for joining me! I&#8217;ll see you again soon in Lesson 5: Clipping Sprite Sheets</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三节：SDL扩展库]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-3-sdl-extension-libraries/"/>
    <updated>2013-01-28T11:49:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-3-sdl-extension-libraries</id>
    <content type="html"><![CDATA[<p>通过上一节的学习，你也许会怀疑SDL是否能读取BMP以外的图片格式。尽管SDL本身并不提供读取非BMP图片的功能，但包括读取多种图片格式的SDL_image，渲染true-type字体的SDL_ttf，支持更多音乐格式的SDL_mixer，支持网络的SDL
_net，数量庞大而又健壮有力的库扩展着SDL的功能。</p>

<!-- more -->


<p>通过使用这些库，我们可以给我们的程序增加更多功能并使很多事情变得容易许多。在此我们只使用SDL_image，以后的课程中我们会讲到其他的扩展库。</p>

<p> In Lesson 0, when you cloned from the Mercurial and built the libraries you should have also downloaded and built the source for SDL_image, SDL_ttf and SDL_mixer, although I was unable to get SDL_mixer to compile with Visual Studio at the time of writing. This part of the tutorial will be updated when SDL 2.0 is officially released to simply contain links to download the libraries.</p>

<p> If you have not done this, head over to the SDL Mercurial and clone and build the extension libraries available there.</p>

<p> To include the headers and library files on Windows simply paste them in the include and lib directories of your SDL 2.0 folder and add SDL_image.lib and etc. to your linker settings. On Linux following the configure, make, make install pattern will spit out a location where the libraries were installed that you can link against.</p>

<p> In addition to setting up the includes and libraries you will also need to put the dlls that are located in the externals folder along with the dll that was created when building the project. Some dlls are dynamically loaded and as such, only needed if you intend to use their functionality, you may consult the extension library page for the specifics on which dlls behave this way.</p>

<p> In addition to exploring the SDL_image library in this lesson we will also begin to learn about throwing and catching exceptions by adding some error handling to our LoadImage function from last time, instead of checking if the returned pointer was still null. This will allow us to get more information about the exact error that happened and help us track down the cause of the error faster.</p>

<p> For this lesson we will simply be adding some extra stuff to the code we wrote in Lesson 2, so let&#8217;s get that open. IDE users will want to add SDL_image to their linker settings as described above, and for those of you compiling with g++ add -lSDL_image or -lSDL2_image depending on how your 2.0 libraries are named.</p>

<p> We&#8217;ll need to add the extra includes for the new things we want to use, SDL_image and stdexcept.</p>

<p> <div><script src='https://gist.github.com/3139999.js?file=1.cpp'></script>
<noscript><pre><code>#include &quot;SDL.h&quot;</p>

<h1>include &quot;SDL_image.h&quot;</h1>

<h1>include &lt;stdexcept&gt;</h1>

<h1>include &lt;string&gt;</h1>

<h1>include &lt;iostream&gt;</code></pre></noscript></div></h1>

<p> From here we setup as before our screen parameters and create a global window and renderer. If you&#8217;re feeling ill from the use of global objects you may want to take a moment.</p>

<div><script src='https://gist.github.com/3139999.js?file=2.cpp'></script>
<noscript><pre><code>const int SCREEN_WIDTH  = 640;
const int SCREEN_HEIGHT = 480;

SDL_Renderer *renderer = nullptr;
SDL_Window *window = nullptr;</code></pre></noscript></div>


<p> Now let&#8217;s rework our LoadImage function to use SDL_image&#8217;s IMG_LoadTexture to directly load a texture from an image. SDL_image supports many image formats: BMP, GIF, JPEG, LBM, PCX, PNG, PNM, TGA, TIFF, WEBP, XCF, XPM, XV and as such is a very powerful and useful library, as we are no longer limited to the BMP format</p>

<p> Reworking our function is surprisingly simple, we just take out the SDL_Surface business and load the texture directly. Note that we now use IMG_GetError() instead of SDL_GetError(), this is because we&#8217;re now using the SDL_image library to load the image, and as such the appropriate error information would be stored there instead of in SDL.</p>

<div><script src='https://gist.github.com/3139999.js?file=3.cpp'></script>
<noscript><pre><code>SDL_Texture* LoadImage(std::string file){
    SDL_Texture* tex = nullptr;
    tex = IMG_LoadTexture(renderer, file.c_str());
    if (tex == nullptr)
        throw std::runtime_error(&quot;Failed to load image: &quot; + file + IMG_GetError());
    return tex;
}</code></pre></noscript></div>


<p> But we&#8217;ve got one more new thing here. Since we&#8217;ve decided to be smart and add more informative error checking if our image fails to load we will throw a runtime_error which will tell us what happened and more helpfully, which image caused the error. However if you leave this error uncaught when you call the function later in your program and it occurs, it will crash the program. Depending on the situation this may be desirable, but at the moment we&#8217;ll want it to tell us what happened as opposed to just crashing.</p>

<p> We&#8217;re almost ready to draw our images, for this lesson we&#8217;ll be using this image as our background:</p>

<p> and our foreground image will be:</p>

<p> If you look at our foreground image you&#8217;ll notice that it has a transparent background, I&#8217;ve set it like this to demonstrate that IMG_LoadTexture will respect alpha channels and that when the texture is drawn the transparent properties will be retained.</p>

<p> Now that we&#8217;ve got our images we can write our loading code, but recall that we&#8217;ll need to add a try/catch structure to handle the error if one is thrown. Also, don&#8217;t forget to set the file paths to match the image locations on your system.</p>

<div><script src='https://gist.github.com/3139999.js?file=4.cpp'></script>
<noscript><pre><code>    SDL_Texture *background = nullptr, *image = nullptr;
    try {
        background = LoadImage(&quot;../res/Lesson3/background.png&quot;);
        image = LoadImage(&quot;../res/Lesson3/image.png&quot;);
    }
    catch (const std::runtime_error &amp;e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    return 4;
    }</code></pre></noscript></div>


<p> In our catch statement we tell the program to print out e.what(), which will display the string that we put into the runtime_error&#8217;s parentheses. Note that depending on how you&#8217;ve configured your project to build you may not get stdout displayed, if that is the case you can simply write the information to a file instead.</p>

<p> The rest of the code is not shown as it is identical to what was written for Lesson 2, so you can just drop in this new functionality into the old program. If you want to mess with the image positions, feel free to play around. When running the program with the same position settings as Lesson 2 you should see this:</p>

<p> Note that the transparency of the foreground image was preserved. This is a very useful effect as it means we won&#8217;t have to use color keying to cut out the background of our images but instead can use simple transparency. However if you do wish to use color keying, it will be covered in later lessons.</p>

<p> End of Lesson 3: SDL Extension Libraries
 If you have issues compiling or running the code make sure that you&#8217;ve added the include paths and linker settings correctly, along with putting the dlls from SDL_image and its dependencies, located in the externals folder of the source code, into the same folder as your executable.</p>

<p> I&#8217;ll see you again soon in Lesson 4: Event Driven Programming!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第二节：别什么都塞进main里]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-2-dont-put-everything-in-main/"/>
    <updated>2013-01-28T00:46:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-2-dont-put-everything-in-main</id>
    <content type="html"><![CDATA[<p>这一节中，我们将通过编写一些非常有用的函数来将上一节我们所写的代码组织起来，在这之中呢，我们会讨论一下图片是怎样在SDL window中确定位置和缩放的。</p>

<!-- more -->


<p>惯例，我们需要在程序开头包含SDL。这一节我们还需要string类，所以我们在开头也包含它。</p>

<div><script src='https://gist.github.com/3139927.js?file=1.cpp'></script>
<noscript><pre><code>#include &quot;SDL.h&quot;
#include &lt;string&gt;

const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;

SDL_Window *window = nullptr;
SDL_Renderer *renderer = nullptr;</code></pre></noscript></div>


<p>We&#8217;ll also declare some constant values for our screen width and height along with global declarations of a window and renderer so that they&#8217;re accessible by our functions. Again we initialize the pointers as nullptr for safety. If you&#8217;re not using C++11 initialize them as NULL.
我们还声明了一些表示窗口宽度和高度的常量，连同window还有renderer的全局变量，以便于所有的函数都能够访问到它们。这里有一次为了安全我们把指针初始化为nullptr.如果你没有使用C++11，那就把它们初始化为NULL吧。</p>

<p>Note: You should avoid using non-constant global values or global values in general as much as possible, ie. you should never ever declare a global SDL_Window or SDL_Renderer. However, for this simple lesson we&#8217;ll let it slide. But it&#8217;s ok if you feel grossed out. We&#8217;ll cover a solution to global objects in a few lessons.
注意：你应该尽可能地避免适用非常量的全局数或者全局变量，这即是说，你从来都不应该声明全局的SDL_Window和SDL_Renderer。尽管这样，在这个简单的课程中，我们不要纠结这个。但是如果你觉得这样做恶心的话，这也没关系。在以后几节课程中，我们将提到一个解决方案。</p>

<p> Remember from Lesson 1 where we loaded a texture? It wasn&#8217;t so bad to just have it in main for loading one image, but what if we had lots images to load? We&#8217;d have to type it out every time! We can do much better, instead let&#8217;s define a function for loading textures from a filename:
还记得在第一节中我们加载了一个texture么。把加载图像的代码放到main里并不是太坏，但是如果我们需要加载很多图像呢？我们不得不每次都要写一遍那些代码！我们可以做得更好——定义一个可以通过文件名来加载texture的函数。</p>

<div><script src='https://gist.github.com/3139927.js?file=2.cpp'></script>
<noscript><pre><code>SDL_Texture* LoadImage(std::string file){
    SDL_Surface *loadedImage = nullptr;
    SDL_Texture *texture = nullptr;
  
    loadedImage = SDL_LoadBMP(file.c_str());
    if (loadedImage != nullptr){
        texture = SDL_CreateTextureFromSurface(renderer, loadedImage);
        SDL_FreeSurface(loadedImage);
    }
    else
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
    return texture;
}</code></pre></noscript></div>


<p> The function here should look very familiar as it&#8217;s the exact same code we wrote in Lesson 1, but now we have wrapped it up in a nice function. With this function we can pass a file name as a string and get back a pointer to the loaded SDL_Texture. Note that the pointer will be nullptr if the loading fails because we initialize both pointers as nullptr for error checking.
这里的这个函数看起来应该非常眼熟才对，因为它就是我们在第一节写的代码。但是这一次，我们把它们用一个美妙的函数包裹了起来。有了这个函数，我们就可以传给它一个文件名的字符串，然后得到一个SDL_Texture的指针。注意，如果图片加载失败了，这个指针会是nullptr，因为我们为了错误检测，把所有的指针都初始化为了nullptr。</p>

<p> Next we&#8217;ll want to write a function to simplify our draw calls and also allow us to specify a position to draw the image too on the screen. We&#8217;ll want it to be able to take an x, y coordinate position along with a texture pointer and a renderer pointer and then draw the texture to that position.
下一步，我们想要写一个可以简化我们绘制调用，并且允许我们指定图像在屏幕上绘制的位置的函数。我们需要它能够取得x, y坐标位置还有一个texture指针，以及一个renderer指针，然后把那个texture画在那个位置。</p>

<div><script src='https://gist.github.com/3139927.js?file=3.cpp'></script>
<noscript><pre><code>void ApplySurface(int x, int y, SDL_Texture *tex, SDL_Renderer *rend){
    SDL_Rect pos;
    pos.x = x;
    pos.y = y;
    SDL_QueryTexture(tex, NULL, NULL, &amp;pos.w, &amp;pos.h);
 
    SDL_RenderCopy(rend, tex, NULL, &amp;pos);
}</code></pre></noscript></div>


<p> In order to specify a position for the texture to be drawn too we need to create a SDL_Rect that we can pass the address to SDL_RenderCopy&#8217;s destination rect parameter. This is done because the last two parameters of SDL_RenderCopy are SDL_Rect pointers, so it&#8217;s expecting an address.
为了指定Texture绘制的位置，我们需要创建一个SDL_Rect，这样我们就可以把它的地址传给SDL_RenderCopy的目标rect参数。这样做是因为SDL_RenderCopy的最后两个参数是SDL_Rect类型的指针，所以需要传入一个地址。</p>

<p>To create our rectangle we take the x and y values that we passed in and the set rectangle&#8217;s values equal to them. However we must also specify the width and height we want the texture to be drawn with as SDL 2.0 also gives us the ability to scale our textures. Try playing with the width and height values once the tutorial is done and see what happens!
为了创建这个矩形（rectangle），我们将传入的x与y赋给rectangle的x和y.另外，我们还必须指定需要texture绘制的宽度和高度，因为SDL2.0在这里赋予了我们缩放texture的能力。在本教程结束后，你可以试着更改高度和宽度并看看会发生什么情况。
For now we just want to pass the texture&#8217;s width and height so that we draw it at a 1:1 scale. We can get these values by using SDL_QueryTexture. This function takes the texture pointer we want to query, the two parameters we pass NULL to are the format and access level parameters respectively, which we can ignore. Finally we must pass the addresses of the variables that we want to fill with the width and height of the texture.
但是现在我们只想把texture原本的宽度和高度传入，以便于以1：1的比例来绘制它。我们可以通过SDL_QueryTexure来获取这些值。这个函数需要我们传入texture的指针，后面两个参数我们传入NULL，它们分别是texture格式（? 待考证函数说明）和访问级别，现在我们可以无视它们。最后我们将需要填texture宽高的变量的地址传入。
 Now that we&#8217;ve got our SDL_Rect set up we can pass it, along with the renderer and texture as before, to SDL_RenderCopy so that our texture will be drawn at the point specified and with its original width and height. The remaining NULL parameter in this function is for taking a clip of the source texture, which we&#8217;ll cover later.
现在我们已经有了SDL_Rect，我们可以把它还有renderer，以及之前的texture传给SDL_RenderCopy ，这样texture就会以它原始的尺寸绘制在我们制定的位置。剩下的那个NULL的参数是为了裁剪原来的texture只用的，这点我们会在后面提及。
 Let&#8217;s see our functions in action. First we&#8217;ve got to start up SDL and create our window and renderer as before. We&#8217;ve also got something new here, SDL_WINDOWPOS_CENTERED. This is an option we can use when creating our window to tell SDL to center its position on the specified axis, here we do it for x and y.
现在我们实际看一下我们的函数。首先我们和以前一样开启SDL，创建窗口还有renderer。这里还有个新东西，SDL_WINDOWPOS_CENTERED.这是个可以用来在创建窗口的时候告诉SDL把窗口设到指定坐标轴中央的选项，这里我们指定的是x和y。</p>

<div><script src='https://gist.github.com/3139927.js?file=4.cpp'></script>
<noscript><pre><code>int main(int argc, char** argv){
    if (SDL_Init(SDL_INIT_EVERYTHING) == -1){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }
 
    window = SDL_CreateWindow(&quot;Lesson 2&quot;, SDL_WINDOWPOS_CENTERED, 
        SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
    if (window == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 2;
    }
    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED 
        | SDL_RENDERER_PRESENTVSYNC);
    if (renderer == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 3;
    }</code></pre></noscript></div>


<p> Now let&#8217;s load up our images. For this lesson we&#8217;ll be drawing a tiled background image and drawing a centered image on top of it. Here&#8217;s our background:
现在我们加载图片。本节我们将绘制一个平铺的背景图还有位于它上面的一张居中的图。张是我们的背景图：</p>

<p><img src="https://raw.github.com/Twinklebear/TwinklebearDev-Lessons/master/res/Lesson2/background.bmp"></p>

<p>And this will be our foreground image:
然后这张是前景图：</p>

<p><img src="https://raw.github.com/Twinklebear/TwinklebearDev-Lessons/master/res/Lesson2/image.bmp"></p>

<p>Let&#8217;s load them up with the LoadImage function we just wrote.
我们用刚才写的LoadImage 函数来加载它。</p>

<div><script src='https://gist.github.com/3139927.js?file=5.cpp'></script>
<noscript><pre><code>    SDL_Texture *background = nullptr, *image = nullptr;
    background = LoadImage(&quot;Lesson2res/background.bmp&quot;);
    image = LoadImage(&quot;Lesson2res/image.bmp&quot;);
    if (background == nullptr || image == nullptr)
        return 4;</code></pre></noscript></div>


<p> Note that you will have to change the file paths to match the relative location of the image to the executable on your system.
注意你也许需要更改文件路径以便与文件实际运行的路径匹配。
 Before we draw the images we&#8217;ll need to know where we want to position them, specifically how we&#8217;ll tile our background and also how we can draw the foreground image centered on the screen. First we&#8217;ll have to understand how SDL&#8217;s coordinate system works, as it is a bit different than the standard 2D Cartesian coordinate system. SDL&#8217;s coordinate system looks like this:
在绘制图片之前，我们需要知道我们要把它们放在那里，特别是我们应该如何平铺背图，还有如何把前景图绘制在屏幕中央。首先，我们必须弄明白SDL的坐标系统是怎样工作的。SDL的坐标系统看起来是这样的：
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/lesson2/sdlcoord.png">
With 0, 0 being in the top-left corner of the screen. Y values increase as we move down the screen and X values increase as we move to the right on the screen. Another thing to note about SDL&#8217;s coordinate system is that the x, y point specified to draw an image at is used as the location to draw the top-left corner of the image, as opposed to the center of the image like some other libraries.
坐标0,0处从屏幕左上角开始。Y坐标从上到下增加，X坐标从左到右增加。另外还有一个需要注意的问题，SDL的坐标系统是，指定的图片绘制的x,y坐标，将以这个坐标为图片左上角的坐标来绘制——而不是像其他一些库一样把这个坐标当作图片的中心。</p>

<p>Before we draw: A note about SDL&#8217;s drawing order: The order in which things are drawn will be the order in which they sit on top of each other, so the first thing drawn is the bottom-most image, and the last image drawn will sit on top of everything.</p>

<p>在绘制之前，还有一个需要注意的问题：SDL的绘制顺序。我们绘制时的顺序就是图像叠加的顺序，所以我们首先绘制的东西将位于最底层，最后绘制的将位于所有图像的最上层。</p>

<p> If you&#8217;ve taken a peek at the background image yet you&#8217;ll have noticed that it has a width of 320 and a height of 240, with a screen that is 640x280 we&#8217;ll need to draw the background image four times to tile it over the window scooting it over by its width or height each time.
如果你看了那张背景图，你会发现这张图长320宽240，如果是640x480的屏幕的话，我们需要把它画四次以覆盖整个窗口，每次都要依据图片长宽来移动图片。
 Before drawing anything, we&#8217;ll want to clear the screen, next we&#8217;ll want to setup the positioning of elements on the window. We can get the width and height of the image again by using the QueryTexture function on the background, this gives us a more versatile method in which we could instead create a for loop to iterate over the positions based on the image width and height, perhaps if we were placing many small tiles. For this case we&#8217;re only drawing it four times, so we can take the &#8216;dumb&#8217; route and just type it out.
在绘制之前，我们需要清屏，然后创建好需要画到窗口中的元素。我们可以通过QueryTexture函数来获取背景图的长和宽，它为我们提供了相较之用一个for循环来迭代图像的长宽的一个更便捷的方法，如果我们需要绘制很多小的tile（方块？就是2D游戏中常见的一张图储存了很多种方块，方块的不同排列组成场景的不同部分。。。的那种方块。= =||）因此，我们只需要画四次，因此，我们可以采取&#8217;哑巴&#8217;的路线，只需键入它。(我承认后半句是google翻译姬= =)</p>

<div><script src='https://gist.github.com/3139927.js?file=6.cpp'></script>
<noscript><pre><code>    SDL_RenderClear(renderer);

    int bW, bH;
    SDL_QueryTexture(background, NULL, NULL, &amp;bW, &amp;bH);
    ApplySurface(0, 0, background, renderer);
    ApplySurface(bW, 0, background, renderer);
    ApplySurface(0, bH, background, renderer);
    ApplySurface(bW, bH, background, renderer);</code></pre></noscript></div>


<p> Now we want to draw our foreground image on top of the background, and centered in the window. We can calculate the center point quite easily but because the point we pass to ApplySurface is the location of the top-left corner of the image we must also apply an offset to the point relative to the image&#8217;s width for x and height for y to put the real center of the image at the center point of the screen.
现在，我们想要把前景图画在背景图上方并在窗口中居中显示。我们可以很容易地计算出中间点的坐标，但是因为传入ApplySurface函数的图片坐标应该在图片左上角，我们必须给这个点应用一个基于原图像宽度和高度的偏移，以把图片正确地放到屏幕中央。</p>

<div><script src='https://gist.github.com/3139927.js?file=7.cpp'></script>
<noscript><pre><code>    int iW, iH;
    SDL_QueryTexture(image, NULL, NULL, &amp;iW, &amp;iH);
    int x = SCREEN_WIDTH / 2 - iW / 2;
    int y = SCREEN_HEIGHT / 2 - iH / 2;
    ApplySurface(x, y, image, renderer);</code></pre></noscript></div>


<p> In order to see our drawing we&#8217;ll have to present the renderer and then have SDL wait for a second or two so we have a chance to see the image.
为了看到我们绘制的结果，我们需要把renderer呈现（present）出来，并且让SDL等待一两秒钟以便于我们能看到显示的图像。</p>

<div><script src='https://gist.github.com/3139927.js?file=8.cpp'></script>
<noscript><pre><code>    SDL_RenderPresent(renderer);
    SDL_Delay(2000);</code></pre></noscript></div>


<p> Finally, we wrap up the program by freeing the memory being used by the textures, renderer and window, quit SDL and return.
最后，我们为了圆满地结束这个程序，需要释放掉texture、renderer还有window所占用的内存，退出SDL并返回。</p>

<div><script src='https://gist.github.com/3139927.js?file=9.cpp'></script>
<noscript><pre><code>    SDL_DestroyTexture(background);
    SDL_DestroyTexture(image);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
 
    SDL_Quit();
  
    return 0;
}</code></pre></noscript></div>


<p> When you compile and run the program your window should look like this:
当你编译并运行了这个程序，你的窗口看起来应该这样的：
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/lesson2/Lesson2_Result.png"></p>

<p> Lesson 2 Extra Challenge!
 Find a way to convert our dumb method of tiling the background into a lean mean for loop! While it may not be so effecient for four background tiles, using a for loop for tiling is a very nice method for placing a large amount of tiles.
 Hint
第二节的额外挑战！</p>

<p> End of Lesson 2: Don&#8217;t Put Everything in Main
 If you have trouble compiling or running the program make sure you&#8217;ve set up the includes, include directories, linker settings and linker directories correctly, along with setting the correct path to the images and placing the SDL.dll in your executable folder. For Linux users there is no SDL.dll but instead make sure you have the runtime libraries in the correct place in your system.</p>

<p> I&#8217;ll see you again soon in Lesson 3: SDL Extension Libraries!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一节: Hello World!]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/lesson-1-hello-world/"/>
    <updated>2013-01-26T20:22:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/lesson-1-hello-world</id>
    <content type="html"><![CDATA[<p>这一节我们将学习将一张图片绘制到屏幕上的简单方法。具体来讲是绘制下面这张图片。</p>

<!-- more -->


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/hello.bmp">
你可以通过右键另存为下载这张图片。<del>这是一个指向一个我建立的Github版本库里的图片的链接，因为这样做会保存一个SDL能够加载的真正的BMP图片。 </del>这个版本库同时也是我教程中例子的源代码和其他相关资源（assets）的主页。如果你丢了资源或者想要偷看一下我的代码，就从<a href = "https://github.com/Twinklebear/TwinklebearDev-Lessons">这里</a>抓好了。但是，不要复制粘贴！</p>

<p>第一步总是include SDL的头文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "SDL.h"</span></code></pre></td></tr></table></div></figure>


<p>注意，这依赖于你的SDL设置。对Linux用户来说，也许需要这样做：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "SDL/SDL.h"
</span><span class='line'>//or
</span><span class='line'>#include "SDL2/SDL.h"
</span><span class='line'>//depending on your configuration</span></code></pre></td></tr></table></div></figure>


<p>——除非你在编译选项里指定了头文件的绝对路径（对linux用户来说）。</p>

<p>首先我们需要启动SDL以便使用它。注意：如果SDL初始化失败的话，它会返回-1。这样的情况下，我们可以使用SDL_GetError()函数来输出错误消息，然后退出程序。</p>

<p>对Visual Studio用户的特殊说明：如果你在连接器选项中把子系统设置为了windows，你将不会看到输出到控制台的结果。要获得这个结果，你必须把子系统改为“未设置”并且把#undef main放到main函数前面。当改回windows子系统的时候，你要确认一下你把#undef main这行代码去掉了，否则你会得到链接错误。</p>

<div><script src='https://gist.github.com/3139888.js?file=a.cpp'></script>
<noscript><pre><code>int main(int argc, char** argv){
    if (SDL_Init(SDL_INIT_EVERYTHING) == -1){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>然后我们还需要创建一个能让我们绘制图像的窗口，我们可以使用SDL_Window:</p>

<div><script src='https://gist.github.com/3139888.js?file=b.cpp'></script>
<noscript><pre><code>    SDL_Window *win = nullptr;
    win = SDL_CreateWindow(&quot;Hello World!&quot;, 100, 100, 640, 480, SDL_WINDOW_SHOWN);
    if (win == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>SDL_CreateWindow这个函数的作用是为我们创建一个窗口，并且返回一个SDL_Window指针。这个函数的第一个参数是窗口的标题，之后是窗口所打开的位置的x,y坐标，之后的参数是窗口的长度和宽度。最后一个参数是窗口的各种flag，因为我们想要窗口在创建之后马上弹出，所以这里我们填SDL_WINDOW_SHOWN。</p>

<p>我们也提供了一些错误安全保障，把指针初始化为了nullptr，并在创建了窗口之后，检查了这个指针是否仍为空。如果创建窗口失败了，这个指针将仍然是空的，这样我们就需要中止这个程序。把指针初始化为空NULL总是很重要的，或者也可以利用C++ 11新标准把它初始化为nullptr。</p>

<p>现在，仅仅只是打开一个窗口对我们来说意义不大，我们需要把东西画到窗口上。所以现在让我们获取一个SDL_Renderer并且运行吧。</p>

<div><script src='https://gist.github.com/3139888.js?file=c.cpp'></script>
<noscript><pre><code>    SDL_Renderer *ren = nullptr;
    ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (ren == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>我们的renderer（渲染器）是用SDL_CreateRenderer这个函数创建的，这个函数还需要我们指定用来绘制的窗口。我们也可以指定一个可选的显卡驱动，或者直接把参数设为-1，好让SDL自动选择适合我们指定的选项的驱动。这样做可能是最好的选择，因为这会让SDL为你选择你所需要的——也就是你在最后一个参数中用那些标志指定的——合适的驱动。</p>

<p>在这里我们指定了SDL_RENDERER_ACCELERATED，因为我们想使用硬件加速的renderer，换句话说就是想利用显卡的力量。我们还指定了 SDL_RENDERER_PRESENTVSYNC标志，因为我们想要使用SDL_RendererPresent这个函数，这个函数将会以显示器的刷新率来更新画面。</p>

<p>注意，在这里我们使用了和之前创建窗口时一样的错误处理方式。</p>

<p>现在是时候加载一张图片并把它画到屏幕上啦！你应该已经把这张图片下载到同一个文件夹下了，或者把这张图放在你生成的可执行文件附近也是可以的。</p>

<p>尽管SDL2.0使用SDL_Texture来用硬件加速绘制图像，我们还是需要使用SDL_LoadBMP函数将图片加载到SDL_Surface中，因为本节我们没有使用SDL_image这个神奇的扩展库（我们以后会用到的）。</p>

<div><script src='https://gist.github.com/3139888.js?file=d.cpp'></script>
<noscript><pre><code>    SDL_Surface *bmp = nullptr;
    bmp = SDL_LoadBMP(&quot;../res/Lesson1/hello.bmp&quot;);
    if (bmp == nullptr){
        std::cout &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return 1;
    }</code></pre></noscript></div>


<p>注意在这里你需要更改传给SDL_LoadBMP的图片路径，以便和你电脑上的图片路径匹配。或者如果你想使用我现在这样的文件结构的话，你也可以保持这个参数原来的样子而不改动。</p>

<p>要有效地利用硬件加速来绘制，我们必须把SDL_Surface转化为SDL_Texture，这样renderer才能够绘制。</p>

<div><script src='https://gist.github.com/3139888.js?file=e.cpp'></script>
<noscript><pre><code>    SDL_Texture *tex = nullptr;
    tex = SDL_CreateTextureFromSurface(ren, bmp);
    SDL_FreeSurface(bmp);</code></pre></noscript></div>


<p>在这里我们也把刚才的SDL_Surface释放掉，因为以后就用不着它了。</p>

<p>现在我们可以把Texture画到renderer上了。首先，我们先使用SDL_RenderClear来清空屏幕，然后我们使用SDL_RenderCopy来把texture画上去。最后，我们使用SDL_RenderPresent来更新屏幕的画面。</p>

<div><script src='https://gist.github.com/3139888.js?file=f.cpp'></script>
<noscript><pre><code>    SDL_RenderClear(ren);
    SDL_RenderCopy(ren, tex, NULL, NULL);
    SDL_RenderPresent(ren);</code></pre></noscript></div>


<p>这里我们给SDL_RenderCopy传了两个NULL值。第一个NULL是一个指向源矩形的指针，也就是说，从图像上裁剪下的一块矩形；而另一个是指向目标矩形的指针。我们将NULL传入这两个参数，是告诉SDL绘制整个源图像（第一个NULL），并把它画在屏幕上（0，0 ）的位置，并拉伸这个图像让它填满整个窗口（第二个NULL）。这一点以后还会详细说明。</p>

<p>我们还用SDL_Delay告诉程序让它等2000毫秒，以便于我们可以看到这个窗口。不让它等待的话，这个窗口就会在弹出之后立刻退出程序。</p>

<div><script src='https://gist.github.com/3139888.js?file=g.cpp'></script>
<noscript><pre><code>    SDL_Delay(2000);</code></pre></noscript></div>


<p>在我们退出程序之前，我们有必要释放掉我们这个窗口、renderer还有texture所用的全部内存。这可以通过调用几个SDL_Destroy来完成。</p>

<div><script src='https://gist.github.com/3139888.js?file=h.cpp'></script>
<noscript><pre><code>    SDL_DestroyTexture(tex);
    SDL_DestroyRenderer(ren);
    SDL_DestroyWindow(win);</code></pre></noscript></div>


<p>退出SDL以停止程序，并且返回0.</p>

<div><script src='https://gist.github.com/3139888.js?file=i.cpp'></script>
<noscript><pre><code>    SDL_Quit();
    return 0;
}</code></pre></noscript></div>


<p>编译并检查这个程序吧！不要忘了把SDL.dll放到你的可执行文件的文件夹里，否则你会得到一个弹出的错误提示。如果你用的是linux系统，你应该已经安装了SDL的共享库了，所以你应该不会遇到什么问题。</p>

<p>现在，恭喜你写出第一个SDL2.0程序！</p>

<p> Troubleshooting
 If your program fails to compile make sure you&#8217;ve properly configured your libraries and linked to the correct path in your include statement.</p>

<p> If your program complains about SDL.dll missing, make sure it is located in the same folder as the executable.</p>

<p> If your program runs but exits with out displaying anything make sure your image path is set correctly. If that doesn&#8217;t help try writing some cout or file output into the program, although depending on your platform and configuration settings cout may not appear.</p>

<p>第一节结束。</p>

<p>这就是第一节了。我们第二节：别把什么都放到main里再见吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译SDL2.0教程】在Visual Studio中配置SDL]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/setting-up-sdl-in-visual-studio/"/>
    <updated>2013-01-26T13:34:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/setting-up-sdl-in-visual-studio</id>
    <content type="html"><![CDATA[<p>既然我们已经把库配置好了，我们就需要在我们的项目中链接SDL库。打开Visual Studio，创建一个新的空白C++工程。<br></p>

<!-- more -->


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setruntimelib.png" title="新建工程" alt="新建工程" /><br>
要让工程识别SDL的头文件和库文件，我们需要编辑几项简单的与包含路径和链接设置有关的选项。
右键单击项目名，打开属性菜单。在C/C++列表下，选择“常规”，然后单击最上面的“附加包含目录”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/settingincludedir.png" title="设置包含目录" alt="设置包含目录" /><br>
选择&#8221;编辑&#8221;。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/additionalincludedir.png" title="附加包含目录" alt="附加包含目录" /><br>
单击“新行”图标增加一行，然后单击文本框右面的浏览按钮（三个点的那个），找到你的SDL文件夹，在其中选择“include”文件夹。点“选择文件夹”，确定并应用以保存你的设置。
下一步我们需要更改运行库。在C/C++列表下，选择“代码生成”，然后找到“运行库”项，把它改为“多线程 DLL (/MD)”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setruntimelib.png" title="运行库" alt="运行库" /><br>
要把库链接上，选择C/c++下面的“连接器（linker）”,选择“常规”，然后点击窗口中间的“附加库目录”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/settinglinkerdir.png" title="链接目录" alt="链接目录" /><br>
和之前一样，点击文本框右侧的朝下的三角箭头按钮，选择编辑。
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/additionallibdir.png" title="附加库目录" alt="附加库目录" /><br>
再一次选择新建，单击浏览按钮。找到你的SDL文件夹，打开lib文件夹，你会看到两个文件夹，32位的x86和64位的x64。你可以任选其一，但是你必须明白VC++默认是编译的32位
程序，你可能需要更改其他设置。在这个教程中，我选择的是x86。点击选择，确认，应用来保存你的设置。<br>
下一步我们必须指定我们将要链接的库文件。于是在连接器菜单里，选择“输入”菜单，点击“附加依赖项”文本框，像之前一样点击右面的三角箭头并选择“编辑”。<br>
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/settinglibinput.png" title="附加依赖项" alt="附加依赖项" /><br>
要让VC++知道我们想要使用的库，填入</p>

<pre><code>SDL.lib; SDLmain.lib;
</code></pre>


<br>


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setadditiondep.png" title="附加依赖项" alt="附加依赖项" /><br>
点击确认，应用来保存设置。
随后一步是将子系统目标改为windows。选择连接器下的“系统”菜单，将“子系统”条目改为Windows。</p>

<br>


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/setsubsystem.png" title="setsubsystem" alt="setsubsystem" /><br>
点击应用，以保存设置，确认关闭窗口。</p>

<br>


<p>现在我们来测试一下我们的配置是否正确。给工程添加一个C++源文件并输入：</p>

<script src="https://gist.github.com/3139836.js"></script>


<p>这段简单的代码将初始化SDL，然后退出。你不会看到任何事发生。尝试编译这个项目，如果有错误提示的话，确认你没有跳过之前任何一步，并确认你是否选择了正确的文件夹。在运行这段代码之前，你应该把SDL路径下，bin文件夹内的动态链接库SDL.dll放到项目可执行文件的文件夹里。否则的话，程序将会运行失败并弹出找不到SDL的错误。<br>
作为最后一件为以后每次创建SDL项目省下麻烦的额外工作，你可以把这个项目导出为一个模板。选择文件菜单然后点击导出模板，然后把它导出为项目模板。你可以给它取个名字也可以为它增加任意你喜欢的描述。现在当我们创建一个新的SDL项目的时候，你只需要选择这个模板，只要你的SDL文件夹没有移动，那么所有的东西都被设置好了。
<img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/exporttemplate.png" title="exporttemplate" alt="exporttemplate" /><br></p>

<br>


<p><img src="http://adolfans.github.com/sdltutorialcn/images/blogimages/1-26/sdltemplate.png" title="sdltemplate" alt="sdltemplate" /><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译SDL2.0教程】第0节：配置SDL]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/lesson-0-setting-up-sdl/"/>
    <updated>2013-01-25T23:28:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/lesson-0-setting-up-sdl</id>
    <content type="html"><![CDATA[<p>  <h3>
SDL2.0说明</h3>
截至到2012年6月17日我写这篇帖子为止，SDL2.0还没有发布官方正式版本，因此你需要用你所用的编辑器自行编译。</p>

<!-- more -->


<p>  <br>
  <br>
  你可以在<a href="http://www.libsdl.org/hg.php">这里</a>下载它。
  <br>
  <br>
你可以从Mecurial版本库里clone一份最新的源码，但下载一份快照也是个不错的选择。在实际写代码的时候，需要clone他们的Mercurial版本库来下载我们要用到的扩展库。
  <br>
  <br>
在下载完之后，就很容易设置了。注意扩展库SDL_image, SDL_ttf还有SDL_mixer是依赖于SDL的，你需要指定包含路径和链接设置来编译，其中SDL要先编译。</p>

<p>  <br>
  <br>
注意源码文件夹里已经包含了怎样在各个平台上编译构建的文档说明，它们应该能够帮你构建并确认一切是否正常，你也可以继续阅读。
  <br>
  <br>
SDL2.0发布官方正式版时，我会更新链接，这样你们就可以直接下载编译好的库，这就更容易了。
  <br>
  <br>
  <h3>
C++11说明</h3>
在这个教程中，我们会使用一些C++11新标准中的特性，因此你可以选择使用支持这些新标准的编译器，也可以把这些代码翻译成你所使用的编译器所支持的代码，这不会太痛苦。Visual Studio 2012支持C++11,如果你用的是GCC，你可以通过增加-std=c++0x的编译选项来启用C++11特性。</p>

<p>  <br>
  <br>
  <h3></p>

<p>Visual Studio</h3>
源码文件夹里应该包含了一个叫VisualC的文件夹，如果你打开项目解决方案时被提示更新项目，照做就是。在构建之前，确定你选择生成的是Release版本。这样解决方案应该会顺利生成。主目录里有一个VisualC.html文件，里面包含的信息如果你在编译出问题的时候应该很有用。
  <br>
  <br></p>

<p>在生成扩展库的时候，确认你生成的是Release版本。注意在你编译之前，你需要指定SDL2.0的包含路径(include directory，头文件路径)和库路径(library directory)。
  <br>
  <br>
  <b>SDL_mixer的说明：</b>
很不幸我没能在Visual Studio中生成SDL_mixer，尽管它能在Linux里正常使用。所以我觉得Visual Studio的工程文件有点问题。
  <br>
  <br>
当你全部生成完所有的库之后，你要把头文件，lib库文件还有dll放到你不会忘得地方，因为我们会在我们的项目中使用到这些文件。我的路径是C:\
  <br>
  <br>
  <a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/setting-up-sdl-in-visual-studio/">这里</a>有如何创建你第一个SDL项目的教程。
  <br>
  <br>
  <h3>
Linux </h3>
Linux用户只需要使用标准的configure,make,make install.注意要记下你的头文件和库文件的安装路径，因为你在之后编译项目的时候需要指定这些路径。另外你也可以把库和头文件移到标准路径下。你可以把运行库放到或者链接到/lib/路径下，或者放到其他存放运行库的备用路径下面。
  <br>
  <br></p>

<p>关于Linux里编译命令的教程在
  <a href="http://twinklebeardev.blogspot.com/2012/07/setting-up-sdl-on-linux-command-line.html">这里</a>。
  .
  <br>
  <br>
  <h3></p>

<p>Mac</h3></p>

<p>源代码文件夹还包含了一个XCode的工程，但我没有Mac电脑所以很不幸我无法提供更多的指导。在源码中包含的文档里查找关于构建这些库以及如何包含头文件和库文件的信息吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译SDL2.0教程】目录]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/sdl-2-dot-0-tutorial-index/"/>
    <updated>2013-01-25T23:12:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/sdl-2-dot-0-tutorial-index</id>
    <content type="html"><![CDATA[<p>原文地址:<a href = "http://twinklebeardev.blogspot.com/p/sdl-20-tutorial-index.html">SDL 2.0 Tutorial Index</a></p>

<h3>Welcome!</h3>


<p>下面的教程目的是为你提供一个关于SDL2.0以及c++中游戏设计主题和概念的介绍。在本教程中，我们假定你对C++有一定程度上的知识，至少了解数组，vector，控制结构，函数还有指针。<br /><br />
如果你觉得理解教程中的代码有困难，你可以在教程后面随意留言，或者在<a href="http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">StackOverflow</a>上的这个列表里抓一本书来读。<br /><br />
如果你想要查看或者下载全部的程序代码，你可以在<a href="https://github.com/Twinklebear/TwinklebearDev-Lessons">Github</a>上下载到。但是不要复制！<br /><br />
SDL2.0的文档现在可以在<a href="http://wiki.libsdl.org/moin.cgi/FrontPage">online wiki</a>上查看到。<br /><br /></p>

<h3>教程目录：</h3>


<p><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-0-setting-up-sdl.html"><b>Lesson 0: Setting up SDL</b></a>&nbsp;<a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/lesson-0-setting-up-sdl/">第0节：配置SDL</a> <br />
<a href="http://twinklebeardev.blogspot.com/2012/07/lesson-1-hello-world.html"><b>Lesson 1: Hello World!</b></a>&nbsp;<a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/26/lesson-1-hello-world/">第一节: Hello World!</a> <br />
<a href="http://twinklebeardev.blogspot.com/2012/07/lesson-2-dont-put-everything-in-main.html"><b>Lesson 2: Don&#8217;t Put Everything in Main</b></a>&nbsp;<a href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-2-dont-put-everything-in-main/">第二节：别什么都塞进main里</a> <br />
<b><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-3-sdl-extension-libraries.html">Lesson 3: SDL Extension Libraries&nbsp;</a></b><br />
<b><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-4-event-driven-programming.html">Lesson 4: Event Driven Programming</a></b><br />
<a href="http://twinklebeardev.blogspot.com/2012/08/lesson-5-clipping-sprite-sheets.html"><b>Lesson 5: Clipping Sprite Sheets&nbsp;&nbsp;</b></a><br />
<a href="http://twinklebeardev.blogspot.com/2012/08/lesson-6-true-type-fonts-with-sdlttf.html"><b>Lesson 6: True Type Fonts with SDL_ttf</b></a><br />
<b><a href="http://twinklebeardev.blogspot.com/2012/09/lesson-7-taking-advantage-of-classes.html">Lesson 7: Taking Advantage of Classes</a></b><br />
<a href="http://twinklebeardev.blogspot.com/2012/10/lesson-8-timers.html"><b>Lesson 8: Timers </b></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello world]]></title>
    <link href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/hello-world/"/>
    <updated>2013-01-25T21:16:00+08:00</updated>
    <id>http://adolfans.github.com/sdltutorialcn/blog/2013/01/25/hello-world</id>
    <content type="html"><![CDATA[<p>这是一个测试。</p>

<pre><code>这是一个代码区块。
</code></pre>

]]></content>
  </entry>
  
</feed>
