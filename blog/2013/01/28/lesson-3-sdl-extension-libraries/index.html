
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>第三节：SDL扩展库 - SDL中文教程</title>
  <meta name="author" content="Adolfans">

  
  <meta name="description" content="原文地址：http://twinklebeardev.blogspot.com/2012/09/lesson-7-taking-advantage-of-classes.html 通过上一节的学习，你也许会怀疑SDL是否能读取BMP以外的图片格式。尽管SDL本身并不提供读取非BMP图片的功能， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-3-sdl-extension-libraries/">
  <link href="/sdltutorialcn/favicon.png" rel="icon">
  <link href="/sdltutorialcn/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/sdltutorialcn/javascripts/modernizr-2.0.js"></script>
  <script src="/sdltutorialcn/javascripts/ender.js"></script>
  <script src="/sdltutorialcn/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/sdltutorialcn/atom.xml" rel="alternate" title="SDL中文教程" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/sdltutorialcn/">SDL中文教程</a></h1>
  
    <h2>_(:3」∠)_目前一团乱还请各位见谅<br>总之各位随意~</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/sdltutorialcn/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:adolfans.github.com/sdltutorialcn" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/sdltutorialcn/">Blog</a></li>
  <li><a href="/sdltutorialcn/blog/archives">Archives</a></li>
  <li><a href="/sdltutorialcn/sdl-2-dot-0-tutorial-index/">SDL2.0教程目录</a></li>
  <li><a href="/sdltutorialcn/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">第三节：SDL扩展库</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-28T11:49:00+08:00" pubdate data-updated="true">Jan 28<span>th</span>, 2013</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>原文地址：<a href="http://twinklebeardev.blogspot.com/2012/09/lesson-7-taking-advantage-of-classes.html">http://twinklebeardev.blogspot.com/2012/09/lesson-7-taking-advantage-of-classes.html</a></p>

<p>通过上一节的学习，你也许会怀疑SDL是否能读取BMP以外的图片格式。尽管SDL本身并不提供读取非BMP图片的功能，但包括读取多种图片格式的SDL_image，渲染true-type字体的SDL_ttf，支持更多音乐格式的SDL_mixer，支持网络的SDL
_net，数量庞大而又健壮有力的库扩展着SDL的功能。</p>

<!-- more -->


<p>通过使用这些库，我们可以给我们的程序增加更多功能并使很多事情变得容易许多。在此我们只使用SDL_image，以后的课程中我们会讲到其他的扩展库。</p>

<p>在第0节中，当你从Mercurial中同步下来一份源码，并且生成库文件之后，你还需要下载并编译SDL_image,SDL_ttf还有SDL_mixer的源码，<del>尽管在写这篇教程的时候我没能在Visual Studio里把SDL_mixer编译成功</del>。(译注:现在去掉MP3格式支持就可以编译成功，详见第〇节译注)当SDL2.0正式发布的时候，我会更新这个教程并提供编译好的库以直接下载。</p>

<p>如果你还没做完这些，回到SDL的mercurial版本库中同步到代码并生成这些扩展库。</p>

<p>在windows下，要包含头文件和库文件，只需要把SDL2.0文件夹中对应路径粘贴到include和lib路径设置中，然后把SDL_image.lib还有其他等等的一些lib文件添加到连接器选项中。在linux中，使用configure，make还有make install的方式，它会告诉你在链接时需要的库安装的路径，</p>

<p>除此之外，你还需要把外部文件夹中的dll放到项目生成dll的文件夹内。某些dll是动态加载的，当你需要它的功能才需要添加。你可以参考扩展库的主页来弄明白哪些dll是这么工作的。</p>

<p>本节除了研究SDL_image库之外，我们还会通过为loadimage函数添加一些错误处理的代码来学习throw与catch异常，以此替代检测返回值是否为NULL的错误处理机制。这允许我们获取实际发生的错误的更多信息，并帮我们更快地追踪到导致错误的原因。</p>

<p>在本节中，我们只会在第二节的代码中添加一些额外的东西，所以让我们打开它。IDE用户需要按前文中所说的，给连接器选项添加SDL_image。对那些使用G++的人来说，取决于你SDL2.0的库名，你可以添加比如-lSDL_image或者-lSDL2_image的链接选项。</p>

<p>我们还要把新东西，SDL_image和stdexcept,include进去.<br/>
 <div><script src='https://gist.github.com/3139999.js?file=1.cpp'></script>
<noscript><pre><code>#include &quot;SDL.h&quot;</p>

<h1>include &quot;SDL_image.h&quot;</h1>

<h1>include &lt;stdexcept&gt;</h1>

<h1>include &lt;string&gt;</h1>

<h1>include &lt;iostream&gt;</code></pre></noscript></div></h1>

<p>从这里开始我们和以往一样设定好屏幕参数并且创建全局的window和renderer。如果你觉得用全局对象不太好，你也许需要等一会儿了。</p>

<div><script src='https://gist.github.com/3139999.js?file=2.cpp'></script>
<noscript><pre><code>const int SCREEN_WIDTH  = 640;
const int SCREEN_HEIGHT = 480;

SDL_Renderer *renderer = nullptr;
SDL_Window *window = nullptr;</code></pre></noscript></div>


<p>现在，我们开始用SDL_image的IMG_LoadTexture函数把之前的LoadImage改成直接从图像文件中读取texture。SDL_image支持许多图像格式：BMP,GIF,JPEG,LBM,PCX,PNG,PNM,TGA,TIFF,WEBP,XCF,XPM,XV.它是个非常强大的库。有了它，我们就不再被BMP格式限制啦~</p>

<p>这回对这个函数的返工简单得让人惊讶。我们只需要去掉SDL_Surface的工作，直接加载texture。注意我们现在使用IMG_GetError()替代SDL_GetError()，因为我们现在正在使用的是SDL_image库来加载图像，因此，对应的错误信息应该在IMG而不是SDL里。</p>

<div><script src='https://gist.github.com/3139999.js?file=3.cpp'></script>
<noscript><pre><code>SDL_Texture* LoadImage(std::string file){
    SDL_Texture* tex = nullptr;
    tex = IMG_LoadTexture(renderer, file.c_str());
    if (tex == nullptr)
        throw std::runtime_error(&quot;Failed to load image: &quot; + file + IMG_GetError());
    return tex;
}</code></pre></noscript></div>


<p>但是我们这里又有另外一个新东西。因为我们决定要让程序变得更智能，并让它的错误处理方式能提供更多错误信息。当我们的图片加载失败之后，我们需要抛出（throw）一个runtime_error的异常，它告诉我们发生了什么，并且告诉我们哪一个图片导致了这项错误。虽然这样，如果你没有捕捉（catch）到这项错误，但之后的运行中这项错误发生了，这个程序还是会崩溃。取决于实际的情况，这或许是可以预计的，但是到崩溃的时候，我们还是希望它告诉我们实际发生了什么而不是直接崩溃。</p>

<p>现在我们准备好绘制图像了，本节我们会用这张图做背景：</p>

<p><img src="https://raw.github.com/Twinklebear/TwinklebearDev-Lessons/master/res/Lesson3/background.png"></p>

<p>前景图是这张：</p>

<p><img src="https://raw.github.com/Twinklebear/TwinklebearDev-Lessons/master/res/Lesson3/image.png"></p>

<p>观察了前景图之后你就会发现它的背景是透明的。我这样做是为了示范IMG_LoadTexture函数可以接受Alpha通道，而当texture绘制出来的时候，会显示出透明的效果。</p>

<p>现在我们有图了，开始编写加载代码。但是先回想一下为了进行错误处理，我们需要添加try/catch结构。还有，别忘了正确地设置图片的文件路径。</p>

<div><script src='https://gist.github.com/3139999.js?file=4.cpp'></script>
<noscript><pre><code>    SDL_Texture *background = nullptr, *image = nullptr;
    try {
        background = LoadImage(&quot;../res/Lesson3/background.png&quot;);
        image = LoadImage(&quot;../res/Lesson3/image.png&quot;);
    }
    catch (const std::runtime_error &amp;e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    return 4;
    }</code></pre></noscript></div>


<p>在catch语句中我们让程序打印出了e.what(),它会显示出我们之前放在runtime_error里的信息。注意，取决于你怎样配置的你的项目，你很可能看不到标准输出的结果（译注：比如VS中的某些编译选项会导致目标程序没有控制台窗口），如果遇到这种情况，你可以把错误信息输出到一个文件里。</p>

<p>剩下的代码我没有放在这里，因为它和第二节中的一样。如果你想改图像的位置，那就改吧。当运行和第二节中图片位置相同的程序的时候，你应该可以看到这个：</p>

<p><img src="/sdltutorialcn/images/blogimages/lesson3/lesson3result.png"></p>

<p>注意前景图的透明度被保留了。这个效果很有用，因为有了它我们就不必使用color key(色彩键？透明色？）来把图片的背景色抠出来，直接使用透明度就可以了。但如果你想使用color key，后面的教程中会讲到。</p>

<p>第三节的结束。</p>

<p>如果你编译或者运行的时候出现了问题，确认你正确地添加了include路径和链接设置，并且把SDL_image还有它的依赖库放在你的可执行文件的文件夹里了。</p>

<p>我们第四节：事件驱动的编程见！</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Adolfans</span></span>

      








  


<time datetime="2013-01-28T11:49:00+08:00" pubdate data-updated="true">Jan 28<span>th</span>, 2013</time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/sdltutorialcn/blog/2013/01/28/lesson-2-dont-put-everything-in-main/" title="Previous Post: 第二节：别什么都塞进main里">&laquo; 第二节：别什么都塞进main里</a>
      
      
        <a class="basic-alignment right" href="/sdltutorialcn/blog/2013/02/12/lesson-4-event-driven-programming/" title="Next Post: 第四节：事件驱动的编程">第四节：事件驱动的编程 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/sdltutorialcn/blog/2013/03/24/lesson-8-timers/">第八节：计时器</a>
      </li>
    
      <li class="post">
        <a href="/sdltutorialcn/blog/2013/03/24/lesson-7-taking-advantage-of-classes/">第七节：充分利用类</a>
      </li>
    
      <li class="post">
        <a href="/sdltutorialcn/blog/2013/03/23/lesson-6-true-type-fonts-with-sdl-ttf/">第六节: 使用SDL_ttf绘制True Type字体</a>
      </li>
    
      <li class="post">
        <a href="/sdltutorialcn/blog/2013/02/14/lesson-5-clipping-sprite-sheets/">第五节：裁剪精灵表</a>
      </li>
    
      <li class="post">
        <a href="/sdltutorialcn/blog/2013/02/12/lesson-4-event-driven-programming/">第四节：事件驱动的编程</a>
      </li>
    
  </ul>
</section>




<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/117151825287907703585?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Adolfans -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'sdltutorialcn';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-3-sdl-extension-libraries/';
        var disqus_url = 'http://adolfans.github.com/sdltutorialcn/blog/2013/01/28/lesson-3-sdl-extension-libraries/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
